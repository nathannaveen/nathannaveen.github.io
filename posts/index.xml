<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on nathan naveen</title><link>https://nathannaveen.dev/posts/</link><description>Recent content in Posts on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 18 Mar 2021 14:10:37 -0400</lastBuildDate><atom:link href="https://nathannaveen.dev/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 266</title><link>https://nathannaveen.dev/posts/leetcode-266/</link><pubDate>Thu, 18 Mar 2021 14:10:37 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-266/</guid><description>266. Palindrome Permutation
The idea of this solution is pretty simple. We add all the letters to a map, and then if there is a extra letter that does not have a partner for the other end of the palindrome add it to the numberOfOnes counter, if the counter is greater than 1 we know that it is not a palindrome. We can explain this with some examples:
There are three main examples that are going to be shown:</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/palindrome-permutation/">266. Palindrome Permutation</a></p>
<p>The idea of this solution is pretty simple. We add all the letters to a map, and then if there is a extra letter that does not have a partner for the other end of the palindrome add it to the <code>numberOfOnes</code> counter, if the counter is greater than <code>1</code> we know that it is not a palindrome. We can explain this with some examples:</p>
<p>There are three main examples that are going to be shown:</p>
<ul>
<li><code>input: &quot;aabbccd&quot;, expected output: true</code>, we can make a map <code>m := ['a' : 2, 'b' : 2, 'c' : 2, 'd' : 1]</code> if we iterate through <code>m</code> we can return <code>true</code> because <code>numberOfOnes = 1</code>. <code>numberOfOnes = 1</code> because <code>'d' : 1</code>. If you don&rsquo;t understand why we return <code>true</code> see that we can swap the letters around to get <code>&quot;abcdcba&quot;</code>.</li>
<li><code>input: &quot;aabb&quot;, expected output: true</code>, we can also make a map <code>m := ['a' : 2, 'b' : 2]</code>. When we iterate through <code>m</code> we get <code>numberOfOnes = 0</code> so we retun true. When we swap around <code>&quot;aabb&quot;</code> we get <code>&quot;abba&quot;</code> which is a palindrome.</li>
<li><code>input: &quot;aabbcd&quot;, expected output: false</code>. We can make a map <code>m := ['a' : 2, 'b' : 2, 'c' : 1, 'd' : 1]</code>. When we iterate through <code>m</code> we can see that <code>numberOfOnes = 2</code> and since <code>numberOfOnes &gt; 1</code> we return <code>false</code>. We return <code>false</code> because however we swap around <code>&quot;aabbcd&quot;</code> we can never get a palindrome because there is an extra <code>c</code> and<code>d</code>.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">canPermutePalindrome</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">rune</span>]<span style="color:#66d9ef">int</span>)
    <span style="color:#a6e22e">numberOfOnes</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
        <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">i</span>]<span style="color:#f92672">++</span>
    }

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
        <span style="color:#a6e22e">numberOfOnes</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>
    }

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">numberOfOnes</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 292</title><link>https://nathannaveen.dev/posts/leetcode-292/</link><pubDate>Thu, 18 Mar 2021 12:19:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-292/</guid><description>292. Nim Game
func canWinNim(n int) bool { return n%4 != 0 } This is all the code we need to solve this problem.
We have to return n % 4 != 0 because we are asked to pick from 1 to 3 stones, and if we pick;
If we pick one stone, the other player can choose three stones If we pick two stones, the other player can select two stones If we pick three stones, the other player can choose one stone As you can see, when we add the stones together in the examples above, they all equal 4 stones.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/nim-game/">292. Nim Game</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">canWinNim</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span><span style="color:#f92672">%</span><span style="color:#ae81ff">4</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>
}
</code></pre></div><p>This is all the code we need to solve this problem.</p>
<p>We have to return <code>n % 4 != 0</code> because we are asked to pick from <code>1</code> to <code>3</code> stones, and if we pick;</p>
<ul>
<li>If we pick one stone, the other player can choose three stones</li>
<li>If we pick two stones, the other player can select two stones</li>
<li>If we pick three stones, the other player can choose one stone</li>
</ul>
<p>As you can see, when we add the stones together in the examples above, they all equal <code>4</code> stones.</p>
<p>We can see that any number that is a multiple of <code>4</code> will return false with these pictures:</p>
<p><img src="https://assets.leetcode.com/users/images/1d18be62-568e-408b-bdc0-e0b2c8025357_1616084116.2890737.jpeg" alt="image"></p>
<p>The next example:</p>
<p><img src="https://assets.leetcode.com/users/images/ed5060f8-e074-4ceb-b646-5c3286ed087e_1616084166.6079986.jpeg" alt="image"></p>
]]></content></item><item><title>Leetcode 1119</title><link>https://nathannaveen.dev/posts/leetcode-1119/</link><pubDate>Thu, 18 Mar 2021 11:32:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1119/</guid><description>1119. Remove Vowels from a String
The first approach is pretty simple. If the letter is not a vowel, add it to a resulting string.
The second approach is better because we keep on using the same string. We remake the string every time there is a vowel by going around the vowel.
This can be shown with some images:
We can have:
input: &amp;quot;leetcode&amp;quot; expected output: &amp;quot;ltcd&amp;quot; We can fast forward to our first vowel, 'e'.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-vowels-from-a-string/">1119. Remove Vowels from a String</a></p>
<p>The first approach is pretty simple. If the letter is not a vowel, add it to a resulting string.</p>
<p>The second approach is better because we keep on using the same string. We remake the string every time there is a vowel by going around the vowel.</p>
<p>This can be shown with some images:</p>
<p>We can have:</p>
<pre><code>input: &quot;leetcode&quot;
expected output: &quot;ltcd&quot;
</code></pre><blockquote>
<p>We can fast forward to our first vowel, <code>'e'</code>.</p>
</blockquote>
<p><img src="https://assets.leetcode.com/users/images/18d37f14-9f11-44bb-aeaa-380a78ed8e79_1616078946.4208002.jpeg" alt="image"></p>
<blockquote>
<p>Now we re-assign our string <code>s</code> to <code>&quot;leetcode&quot;</code> without the <code>'e'</code> and we get:</p>
</blockquote>
<p><img src="https://assets.leetcode.com/users/images/84537cdb-336d-45c1-9c74-3d2963e8d74f_1616079116.1516426.jpeg" alt="image"></p>
<blockquote>
<p>We have circled the letter <code>'t'</code> because <code>i == 2</code> but we forgot about the second <code>'e'</code> so we subtract <code>1</code> from <code>i</code> and we get:</p>
</blockquote>
<p><img src="https://assets.leetcode.com/users/images/d7f8958f-e111-44b7-b0e0-49715e6033e9_1616079273.371251.jpeg" alt="image"></p>
<blockquote>
<p>As we can see, <code>'e'</code> is a vowel, so we have to remake the string to:</p>
</blockquote>
<p><img src="https://assets.leetcode.com/users/images/ade21b1b-388e-420e-ad0b-606b55326c13_1616079425.8852704.jpeg" alt="image"></p>
<blockquote>
<p><em>Note: As you can see, we skipped a lot of the letter because it would take a lot longer if we didn&rsquo;t ignore them</em></p>
<p>You can see that the <code>'o'</code> is a vowel, so we can remake the string to:</p>
</blockquote>
<p><img src="https://assets.leetcode.com/users/images/785dcddd-63ab-403f-9e31-e77ee37ed4fc_1616079718.1413827.jpeg" alt="image"></p>
<blockquote>
<p>We skipped some more letters again because the other letters were not needed.</p>
<p>The <code>'e'</code> is a vowel, so we can remake the string to:</p>
</blockquote>
<p><img src="https://assets.leetcode.com/users/images/c437f9a8-4422-4153-bd63-616a7e11c0f5_1616079950.2055788.jpeg" alt="image"></p>
<p>As we can see, <code>ltdc</code> is equal to our expected output.</p>
<p><strong>The First Code:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">removeVowels</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {
    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;&#34;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i2</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i2</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i2</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;e&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i2</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;i&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i2</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;o&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i2</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;u&#39;</span> {
            <span style="color:#a6e22e">res</span> <span style="color:#f92672">+=</span> string(<span style="color:#a6e22e">i2</span>)
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">removeVowels</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;e&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;i&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;o&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;u&#39;</span> {
            <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[:<span style="color:#a6e22e">i</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]
            <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 1138</title><link>https://nathannaveen.dev/posts/leetcode-1138/</link><pubDate>Thu, 18 Mar 2021 11:32:42 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1138/</guid><description>1138. Alphabet Board Path
I have to admit the code might look daunting but it is actualy not that complicated after I explain it to you.
What the Problem is asking:
The problem asks us to make a board of letters:
[ [a, b, c, d, e] [f, g, h, i, j] [k, l, m, n, o] [p, q, r, s, t] [u, v, w, x, y] [z] ] Then it gives us a word target.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/alphabet-board-path/submissions/">1138. Alphabet Board Path</a></p>
<p><em>I have to admit the code might look daunting but it is actualy not that complicated after I explain it to you.</em></p>
<p><strong>What the Problem is asking:</strong></p>
<p>The problem asks us to make a board of letters:</p>
<pre><code>[
[a, b, c, d, e]
[f, g, h, i, j]
[k, l, m, n, o]
[p, q, r, s, t]
[u, v, w, x, y]
[z]
]
</code></pre><p>Then it gives us a word <code>target</code>. We start at the position <code>(0, 0)</code> which is the letter <code>a</code> on the board.</p>
<p>We are asked to split <code>target</code> into letters and then go from the current position to the letter, and then from the new position to the next letter, and so on.</p>
<p>If we:</p>
<ul>
<li>go right then add a <code>R</code> to the result</li>
<li>go left then add a <code>L</code> to the result</li>
<li>go up then add a <code>U</code> to the result</li>
<li>go down then add a <code>D</code> to the result</li>
<li>reach the letter we add a <code>!</code> to the result</li>
</ul>
<p>We can show this with the following example:</p>
<pre><code>input: 

    target = &quot;leet&quot;

output:

    &quot;DDR!UURRR!!DDD!&quot;
</code></pre><p><img src="https://i.imgur.com/ZxVnZJZ.jpg" alt=""></p>
<p><img src="https://i.imgur.com/6f4mbqt.jpg" alt=""></p>
<blockquote>
<p>The first letter is <code>l</code> so we have to go to the letter <code>l</code> from <code>a</code>. So we go <code>2</code> down and <code>1</code> right. So we add <code>DDR!</code> to the result.</p>
</blockquote>
<p><img src="https://i.imgur.com/5Ox3cCZ.jpg" alt=""></p>
<blockquote>
<p>The second letter is <code>e</code> so we we have to first go up <code>2</code> and right <code>3</code>. Doing this we add <code>UURRR!</code> to the result.</p>
</blockquote>
<p><img src="https://i.imgur.com/2aqk8sw.jpg" alt=""></p>
<blockquote>
<p>The third letter is an <code>e</code> as well, so we just have to add a <code>!</code> to the result.</p>
</blockquote>
<p><img src="https://i.imgur.com/jJjDdUL.jpg" alt=""></p>
<blockquote>
<p>Since the last letter is <code>t</code> we just go down <code>3</code> from our current possition, so we just add <code>DDD!</code> to the result.</p>
</blockquote>
<p>After we have finished we can see that our result is <code>&quot;DDR! + UURRR! + ! + DDD!&quot; = &quot;DDR!UURRR!!DDD!&quot;</code> and our expected output is <code>&quot;DDR!UURRR!!DDD!&quot;</code>, and we can also see that our expected output is equal to our output.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">alphabetBoardPath</span>(<span style="color:#a6e22e">target</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {

    <span style="color:#a6e22e">board</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;abcde&#34;</span>, <span style="color:#e6db74">&#34;fghij&#34;</span>, <span style="color:#e6db74">&#34;klmno&#34;</span>, <span style="color:#e6db74">&#34;pqrst&#34;</span>, <span style="color:#e6db74">&#34;uvwxy&#34;</span>, <span style="color:#e6db74">&#34;z&#34;</span>}
    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;&#34;</span>
    <span style="color:#a6e22e">row</span>, <span style="color:#a6e22e">col</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">target</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">newCol</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">newCol</span> &lt; <span style="color:#ae81ff">6</span>; <span style="color:#a6e22e">newCol</span><span style="color:#f92672">++</span> {
            <span style="color:#a6e22e">newRow</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">containsPosition</span>(<span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">newCol</span>], int32(<span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">i</span>]))
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newRow</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> { <span style="color:#75715e">// this says that the row contains the letter
</span><span style="color:#75715e"></span>                <span style="color:#a6e22e">amountOfRowsLeft</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">abs</span>(<span style="color:#a6e22e">newCol</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">col</span>)

                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newCol</span> &gt; <span style="color:#a6e22e">col</span> {
                    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">col</span>; <span style="color:#a6e22e">k</span> &lt; <span style="color:#a6e22e">newCol</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
                        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">k</span> &gt; len(<span style="color:#a6e22e">board</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span> {
                            <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span>
                            <span style="color:#66d9ef">break</span>
                        }
                        <span style="color:#a6e22e">res</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;D&#34;</span>
                        <span style="color:#a6e22e">amountOfRowsLeft</span><span style="color:#f92672">--</span>
                    }
                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newCol</span> &lt; <span style="color:#a6e22e">col</span> {
                    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">k</span> &lt; <span style="color:#a6e22e">col</span><span style="color:#f92672">-</span><span style="color:#a6e22e">newCol</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
                        <span style="color:#a6e22e">res</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;U&#34;</span>
                        <span style="color:#a6e22e">amountOfRowsLeft</span><span style="color:#f92672">--</span>
                    }
                }

                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newRow</span> &gt; <span style="color:#a6e22e">row</span> {
                    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">k</span> &lt; <span style="color:#a6e22e">newRow</span><span style="color:#f92672">-</span><span style="color:#a6e22e">row</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
                        <span style="color:#a6e22e">res</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;R&#34;</span>
                    }
                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newRow</span> &lt; <span style="color:#a6e22e">row</span> {
                    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">k</span> &lt; <span style="color:#a6e22e">row</span><span style="color:#f92672">-</span><span style="color:#a6e22e">newRow</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
                        <span style="color:#a6e22e">res</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;L&#34;</span>
                    }
                }

                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">amountOfRowsLeft</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
                    <span style="color:#a6e22e">res</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;D&#34;</span>
                }
                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">amountOfRowsLeft</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
                    <span style="color:#a6e22e">res</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;!&#34;</span>
                }
                <span style="color:#a6e22e">row</span>, <span style="color:#a6e22e">col</span> = <span style="color:#a6e22e">newRow</span>, <span style="color:#a6e22e">newCol</span>
                <span style="color:#66d9ef">break</span>
            }
        }
    }

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">containsPosition</span>(<span style="color:#a6e22e">theRow</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">letter</span> <span style="color:#66d9ef">int32</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#75715e">/*
</span><span style="color:#75715e">        This checks whether theRow contains the letter
</span><span style="color:#75715e">    */</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i2</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">theRow</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i2</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">letter</span> {
            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">abs</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &gt; <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">a</span>
}

</code></pre></div>]]></content></item><item><title>Leetcode 1041</title><link>https://nathannaveen.dev/posts/leetcode-1041/</link><pubDate>Tue, 16 Mar 2021 12:41:13 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1041/</guid><description>1041. Robot Bounded In Circle
What the problem is asking:
The problem says that it will give a string with the letters &amp;quot;L&amp;quot;, &amp;quot;R&amp;quot; and &amp;quot;G&amp;quot; to command a robot. &amp;quot;L&amp;quot; means to turn left 90 degrees, &amp;quot;R&amp;quot; means to turn right 90 degrees, and &amp;quot;G&amp;quot; means to go forward one unit. The problem says to return true if the robot can continue in that pattern forever and keep going in a circle.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/robot-bounded-in-circle/">1041. Robot Bounded In Circle</a></p>
<p><strong>What the problem is asking:</strong></p>
<p>The problem says that it will give a string with the letters <code> &quot;L&quot;, &quot;R&quot;</code> and <code>&quot;G&quot;</code> to command a robot. <code>&quot;L&quot;</code> means to turn left 90 degrees, <code>&quot;R&quot;</code> means to turn right 90 degrees, and <code>&quot;G&quot;</code> means to go forward one unit. The problem says to return <code>true</code> if the robot can continue in that pattern forever and keep going in a circle. This can be shown with the following example:</p>
<pre><code>input := &quot;GL&quot;
expected output := true
</code></pre><p>I have depicted how this example works with the following picture:</p>
<p><img src="https://i.imgur.com/qZFauur.jpg" alt=""></p>
<blockquote>
<ul>
<li>In the first image, we start off at the point <code>(0, 0)</code></li>
<li>In the second image, we do the input <code>&quot;GL&quot;</code>, we go up one unit and then turn left, <em>(I have put a dotted line with an arrow to signify that we are going left in the next move)</em></li>
<li>In the following image, we do the <code>&quot;GL&quot;</code> again.</li>
<li>In the fourth image, we do <code>&quot;GL&quot;</code> again.</li>
<li>In the fifth image, we have finished the circle by doing <code>&quot;GL&quot;</code> again.</li>
<li>And in the sixth image, we can see that this keeps on repeating.</li>
</ul>
<p>I have not added anymore because I think it is pretty self-explanatory</p>
</blockquote>
<p><strong>What my code is doing:</strong></p>
<p>We use the variables <code>x, y' and </code>degree<code>. </code>x<code>and</code>y<code>signify where the current position is. And</code>degree<code>is what angle you are pointing at. We use</code>4` numbers to signify this:</p>
<ul>
<li><code>degree = 0</code> means pointing up</li>
<li><code>degree = 1</code> means pointing right</li>
<li><code>degree = 2</code> means pointing down</li>
<li><code>degree = 3</code> means pointing left</li>
</ul>
<p>Next, we have to know when to add and subtract from <code>x</code> and `y'.</p>
<ul>
<li>If <code>degree == 0 &amp;&amp; letter == 'G'</code> then add one to <code>y</code></li>
<li>If <code>degree == 1 &amp;&amp; letter == 'G'</code> then add one to <code>x</code></li>
<li>If <code>degree == 2 &amp;&amp; letter == 'G'</code> then subtract one to <code>y</code></li>
<li>If <code>degree == 3 &amp;&amp; letter == 'G'</code> then subtract one to <code>x</code></li>
</ul>
<p>Then to check whether <code>return true || return false</code>. We can see that if the robot returns to the origin at its last move, it has to be going in a circle, and if it is not facing <code>up</code> we know that it will make a circle after some time. If you don&rsquo;t understand the part of not facing up, look at the image below.</p>
<p><img src="https://i.imgur.com/jpzxNOG.jpg" alt=""></p>
<blockquote>
<p>This is the same example as the example above <code>input := &quot;GL&quot;</code>, when we go through the string we get the image above, as we saw in the last instance, if we continue to make this pattern, we get a circle so as return <code>true</code> for this.</p>
<p>You can try this with an example. It will be <code>true</code> for any degree that is not facing up.</p>
</blockquote>
<p><strong>The Code:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isRobotBounded</span>(<span style="color:#a6e22e">instructions</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">degree</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">instructions</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;R&#39;</span> {
            <span style="color:#a6e22e">degree</span> = (<span style="color:#a6e22e">degree</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>
            <span style="color:#66d9ef">continue</span>
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;L&#39;</span> {
            <span style="color:#a6e22e">degree</span> = (<span style="color:#a6e22e">degree</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>
            <span style="color:#66d9ef">continue</span>
        } 

        <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">degree</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#a6e22e">y</span><span style="color:#f92672">++</span>
        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#a6e22e">x</span><span style="color:#f92672">++</span>
        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>:
            <span style="color:#a6e22e">y</span><span style="color:#f92672">--</span>
        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span>:
            <span style="color:#a6e22e">x</span><span style="color:#f92672">--</span>
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">degree</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>
}
</code></pre></div><p><strong>We can take out the switch case and make the code:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isRobotBounded</span>(<span style="color:#a6e22e">instructions</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">degree</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">addSubtractXAndY</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">instructions</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;R&#39;</span> {
            <span style="color:#a6e22e">degree</span> = (<span style="color:#a6e22e">degree</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;L&#39;</span> {
            <span style="color:#a6e22e">degree</span> = (<span style="color:#a6e22e">degree</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">degree</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">degree</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
                <span style="color:#a6e22e">y</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">addSubtractXAndY</span>[<span style="color:#a6e22e">degree</span>]
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">addSubtractXAndY</span>[<span style="color:#a6e22e">degree</span>]
            }
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">degree</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 692</title><link>https://nathannaveen.dev/posts/leetcode-692/</link><pubDate>Mon, 15 Mar 2021 11:52:46 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-692/</guid><description>692. Top K Frequent Words
The Main Idea:
This solution first adds the words to an array called frequency and sorts frequency after that, return the k most frequency words.
Adding to the array Frequency:
You might be confused when we do this part:
for _, ints := range frequency { if words[ints[0]] == word { contains = true ints[1]++ break } } We can simplify the if statement into if words[frequency[i][0]] = word.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/top-k-frequent-words/">692. Top K Frequent Words</a></p>
<p><strong>The Main Idea:</strong></p>
<p>This solution first adds the words to an array called <code>frequency</code> and sorts <code>frequency</code> after that, return the <code>k</code> most frequency words.</p>
<p><strong>Adding to the array <code>Frequency</code>:</strong></p>
<p>You might be confused when we do this part:</p>
<pre><code>for _, ints := range frequency {
    if words[ints[0]] == word {
        contains = true
        ints[1]++
        break
    }
}
</code></pre><p>We can simplify the <code>if</code> statement into <code>if words[frequency[i][0]] = word</code>. This looks a little weird. We have to do this to get the word for each frequency because the array <code>words</code> is an array of strings, while a frequency is integers. So <code>frequency</code> is an matrix array of <code>[int][int]</code> because we can&rsquo;t do <code>[string][int]</code>, basically <code>frequency</code> is <code>[the index of the first word with this word][frequency]</code>. This might still be a little confusing, so I drew up some pictures I describe it:</p>
<p>The input:</p>
<p><img src="https://i.imgur.com/DDnSxUW.jpg" alt=""></p>
<p>Next:</p>
<p><img src="https://i.imgur.com/4urAoah.jpg" alt=""></p>
<blockquote>
<p>As you can see, our word is <code>taco</code>. Since it is at the <code>0th</code> index and there is only one of it, we can add the array <code>[0, 1]</code> to <code>frequency</code>.</p>
</blockquote>
<p>Then:</p>
<p><img src="https://i.imgur.com/I7OztWX.jpg" alt=""></p>
<blockquote>
<p>The new current word is <code>sunny</code>, and since it is at the <code>1st</code> index and there is only <code>1</code> sunny so far, we can add the array <code>[1, 1]</code> to the array.</p>
</blockquote>
<p><img src="https://i.imgur.com/csUnLCw.jpg" alt=""></p>
<blockquote>
<p>This is just like the previous two parts since there is only <code>1</code> word <code>day</code> so far and the index is <code>2</code> we can add the array <code>[2, 1]</code></p>
</blockquote>
<p><img src="https://i.imgur.com/S8WjhpX.jpg" alt=""></p>
<blockquote>
<p>Now we have something different, we can do <code>if words[ints[0]] == word</code> and it outcomes as <code>true</code> (Remember that <code>if words[ints[0]] == word</code> equals <code>if words[frequency[i][0]] == word</code>). We can put the index of the word which is in <code>ints [0]</code> and then put it back into <code>words</code>, and we get the word, then we check whether that word is equal to the current word. If it is, we can add one to the frequency because they are both the same word.</p>
</blockquote>
<p>We can continue to do this until the end:</p>
<p><img src="https://i.imgur.com/v1oWouh.jpg" alt=""></p>
<blockquote>
<p>When we just continue doing this we get the matrix array <code>[[0, 2][1, 2], [2, 2]]</code> for <code>frequency</code>.</p>
</blockquote>
<p><strong>The Sort:</strong></p>
<p>The sorted array can be shown using another post of mine <a href="https://nathannaveen.dev/posts/leetcode-973/">Leetcode: 973</a> about the middle of the page, and it will say <code>The Idea Of This Solution:</code>, that is where it starts. That post is pretty similar but not the same, so you can look at that to get the main idea of the sort.</p>
<p><strong>Getting the K most Frequent:</strong></p>
<p>We get the <code>k</code> most frequent elements from the matrix array <code>frequency</code>. Since the matrix is sorted from smallest to greatest, we have to loop from the index of the last element to the last element&rsquo;s index minus <code>k</code>.</p>
<p><strong>The Code:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">topKFrequent</span>(<span style="color:#a6e22e">words</span> []<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">string</span> {
    <span style="color:#a6e22e">frequency</span> <span style="color:#f92672">:=</span> [][]<span style="color:#66d9ef">int</span>{}
    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{}

    <span style="color:#a6e22e">frequency</span> = <span style="color:#a6e22e">addWordsToFrequency</span>(<span style="color:#a6e22e">words</span>, <span style="color:#a6e22e">frequency</span>)

    <span style="color:#a6e22e">sortFrequency</span>(<span style="color:#a6e22e">words</span>, <span style="color:#a6e22e">frequency</span>)

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">frequency</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> len(<span style="color:#a6e22e">frequency</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">k</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
        <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">words</span>[<span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">0</span>]])
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addWordsToFrequency</span>(<span style="color:#a6e22e">words</span> []<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">frequency</span> [][]<span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
    <span style="color:#75715e">/*
</span><span style="color:#75715e">       adding all the words to the matrix called frequency
</span><span style="color:#75715e">
</span><span style="color:#75715e">           * first check whether frequency has the word in it, if it does
</span><span style="color:#75715e">           add one to the frequency, if it doesn&#39;t add another word to the
</span><span style="color:#75715e">           array with a frequency of 1
</span><span style="color:#75715e">    */</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">word</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">words</span> {
        <span style="color:#a6e22e">contains</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>

        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ints</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">frequency</span> {
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">words</span>[<span style="color:#a6e22e">ints</span>[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">==</span> <span style="color:#a6e22e">word</span> {
                <span style="color:#a6e22e">contains</span> = <span style="color:#66d9ef">true</span>
                <span style="color:#a6e22e">ints</span>[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">++</span>
                <span style="color:#66d9ef">break</span>
            }
        }
        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">contains</span> {
            <span style="color:#a6e22e">frequency</span> = append(<span style="color:#a6e22e">frequency</span>, []<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">i</span>, <span style="color:#ae81ff">1</span>})
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">frequency</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sortFrequency</span>(<span style="color:#a6e22e">words</span> []<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">frequency</span> [][]<span style="color:#66d9ef">int</span>) {
    
    <span style="color:#75715e">/*
</span><span style="color:#75715e">    This fuction sorts the matrix called frequency.
</span><span style="color:#75715e">    */</span>
    
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">frequency</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">1</span>] &lt; <span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">||</span>
            (<span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&amp;&amp;</span> 
            <span style="color:#a6e22e">words</span>[<span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">0</span>]] &gt; <span style="color:#a6e22e">words</span>[<span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]])) {

            <span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">frequency</span>[<span style="color:#a6e22e">i</span>]
            <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>
        }
    }
}
</code></pre></div>]]></content></item><item><title>Leetcode 1721</title><link>https://nathannaveen.dev/posts/leetcode-1721/</link><pubDate>Sun, 14 Mar 2021 15:57:58 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1721/</guid><description>1721. Swapping Nodes in a Linked List
The idea of this solution is pretty simple.
First, we find the length of the linked list Next, we iterate through the linked list up until the ending kth node And then we iterate through the linked list to to kth node Then, last of all, switch the value of the kth node with the value of the kth node from the end.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/swapping-nodes-in-a-linked-list/">1721. Swapping Nodes in a Linked List</a></p>
<p>The idea of this solution is pretty simple.</p>
<ul>
<li>First, we find the length of the linked list</li>
<li>Next, we iterate through the linked list up until the ending <code>kth</code> node</li>
<li>And then we iterate through the linked list to to <code>kth</code> node</li>
<li>Then, last of all, switch the value of the <code>kth</code> node with the value of the <code>kth</code> node from the end.</li>
</ul>
<p>Finding the length of the linked list is pretty simple. Just get a counter. In this problem, it is <code>lengthOfLinkedList</code>, then iterate through the linked list and add one to the counter every iteration.</p>
<p>We get the <code>kth</code> node from the end by iterating a counter <code>i</code> through <code>0</code> to <code>lengthOfLinkedList - k</code>, <code>lengthOfLinkedList - k</code> gets the length of the linked list and then subtracts <code>k</code> from it, so we get the ending <code>kth</code> node.</p>
<p>We get the <code>kth</code> node by just iterating through <code>0</code> to <code>k - 1</code>. We do <code>k - 1</code> because we do <code>first = first.Next</code> which makes it the next value.</p>
<p>Then we switch the two values by just assigning them to each other if you don&rsquo;t understand <code>second.Val, first.Val = first.Val, second.Val</code> it is basically:</p>
<pre><code>temp := second.Val

second.Val = first.Val
first.Val = temp
</code></pre><p><strong>The code:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">swapNodes</span>(<span style="color:#a6e22e">head</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span> {
    <span style="color:#a6e22e">first</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">head</span>
    <span style="color:#a6e22e">second</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">head</span>
    <span style="color:#a6e22e">findLength</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">head</span>
    <span style="color:#a6e22e">lengthOfLinkedList</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">findLength</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">lengthOfLinkedList</span><span style="color:#f92672">++</span>
        <span style="color:#a6e22e">findLength</span> = <span style="color:#a6e22e">findLength</span>.<span style="color:#a6e22e">Next</span>
    }

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">lengthOfLinkedList</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">second</span> = <span style="color:#a6e22e">second</span>.<span style="color:#a6e22e">Next</span>
    }

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">k</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">first</span> = <span style="color:#a6e22e">first</span>.<span style="color:#a6e22e">Next</span>
    }

    <span style="color:#a6e22e">second</span>.<span style="color:#a6e22e">Val</span>, <span style="color:#a6e22e">first</span>.<span style="color:#a6e22e">Val</span> = <span style="color:#a6e22e">first</span>.<span style="color:#a6e22e">Val</span>, <span style="color:#a6e22e">second</span>.<span style="color:#a6e22e">Val</span>
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">head</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 1329</title><link>https://nathannaveen.dev/posts/leetcode-1329/</link><pubDate>Sat, 13 Mar 2021 10:42:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1329/</guid><description>1329. Sort the Matrix Diagonally
The idea of this solution is kind of hard to explain so I will show it with the following images:
i = len(mat), and j = len(mat[0])
The yellow part is every where i and j will iterate
the diagonal lines are in red
Before we continue you might be confused about why we switch 2 and 1 even though i = 1 and j = 1.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/sort-the-matrix-diagonally/">1329. Sort the Matrix Diagonally</a></p>
<p>The idea of this solution is kind of hard to explain so I will show it with the following images:</p>
<p><img src="https://i.imgur.com/aoRkExV.jpg" alt=""></p>
<blockquote>
<p><code>i = len(mat)</code>, and <code>j = len(mat[0])</code></p>
</blockquote>
<blockquote>
<p>The yellow part is every where <code>i</code> and <code>j</code> will iterate</p>
</blockquote>
<blockquote>
<p>the diagonal lines are in red</p>
</blockquote>
<p><img src="https://i.imgur.com/vfJAh1L.jpg" alt=""></p>
<blockquote>
<p>Before we continue you might be confused about why we switch <code>2</code> and <code>1</code> even though <code>i = 1</code> and <code>j = 1</code>. This can be shown with the example array <code>[3, 2, 1] </code> we can pretend that <code>3, 2, 1</code> is diagonal:</p>
</blockquote>
<pre><code>3
 2
  1
</code></pre><p>When we switch <code>3</code> and <code>2</code></p>
<pre><code>2
 3
  1
</code></pre><p>Then when we switch <code>3</code> and <code>1</code></p>
<pre><code>2
 1
  3
</code></pre><p>This is not sorted, so we have to switch <code>1</code> and <code>2</code></p>
<pre><code>1
 2
  3
</code></pre><p><img src="https://i.imgur.com/hmdt5Jx.jpg" alt=""></p>
<p><strong>The Code:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">diagonalSort</span>(<span style="color:#a6e22e">mat</span> [][]<span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">mat</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; len(<span style="color:#a6e22e">mat</span>[<span style="color:#ae81ff">0</span>])<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
            <span style="color:#a6e22e">newI</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#a6e22e">newJ</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">k</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">newI</span>, <span style="color:#a6e22e">newJ</span>); <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">mat</span>[<span style="color:#a6e22e">newI</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span>][<span style="color:#a6e22e">newJ</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span>] &gt; <span style="color:#a6e22e">mat</span>[<span style="color:#a6e22e">newI</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#a6e22e">newJ</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] {

                    <span style="color:#a6e22e">mat</span>[<span style="color:#a6e22e">newI</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span>][<span style="color:#a6e22e">newJ</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span>], <span style="color:#a6e22e">mat</span>[<span style="color:#a6e22e">newI</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#a6e22e">newJ</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] = 
                    <span style="color:#a6e22e">mat</span>[<span style="color:#a6e22e">newI</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#a6e22e">newJ</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">mat</span>[<span style="color:#a6e22e">newI</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span>][<span style="color:#a6e22e">newJ</span><span style="color:#f92672">-</span><span style="color:#a6e22e">k</span>]
                }
            }
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">mat</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#a6e22e">b</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 1461</title><link>https://nathannaveen.dev/posts/leetcode-1461/</link><pubDate>Fri, 12 Mar 2021 12:03:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1461/</guid><description>1461. Check If a String Contains All Binary Codes of Size K
The idea of this solution is to make a sliding window and add all the substrings os size k to a map, if the maps length is equal to 2^k return true.
We do 2^k because we have to acount for all posibilitys of 0 and 1.
func hasAllCodes(s string, k int) bool { m := make(map[string]int) for i := 0; i &amp;lt; len(s)-k+1; i++ { m[s[i:i+k]]++ } return len(m) == twoPow(k) } func twoPow(k int) int { res := 1 for i := 0; i &amp;lt; k; i++ { res *= 2 } return res } By using bit maniplation we can simplify the code, left shifting is basicly multiplying by 2.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/">1461. Check If a String Contains All Binary Codes of Size K</a></p>
<p>The idea of this solution is to make a sliding window and add all the substrings os size <code>k</code> to a map, if the maps length is equal to <code>2^k</code> return <code>true</code>.</p>
<p>We do <code>2^k</code> because we have to acount for all posibilitys of <code>0</code> and <code>1</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hasAllCodes</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>:<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#a6e22e">k</span>]]<span style="color:#f92672">++</span>
    }

    <span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">m</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">twoPow</span>(<span style="color:#a6e22e">k</span>) 
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">twoPow</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">k</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">res</span> <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
}
</code></pre></div><p><em>By using bit maniplation we can simplify the code, left shifting is basicly multiplying by <code>2</code>. This can be shown using the following:</em></p>
<pre><code>2^0 = 1    1 &lt;&lt; 0 = 1

2^1 = 2    1 &lt;&lt; 1 = 2

2^2 = 4    1 &lt;&lt; 2 = 4
</code></pre><p><strong>The simplifyed the code:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hasAllCodes</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">k</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>:<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#a6e22e">k</span>]]<span style="color:#f92672">++</span>
    }

    <span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">m</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">k</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 1401</title><link>https://nathannaveen.dev/posts/leetcode-1401/</link><pubDate>Fri, 12 Mar 2021 11:01:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1401/</guid><description>1401. Circle and Rectangle Overlapping
The Main Idea
The idea of this solution is to find the distance from the middle of the circle to the edge of a rectangle, and if the distance is smaller than or equal to the radius, we know that the rectangle overlaps with the circle.
If you don&amp;rsquo;t understand, look at the following images:
As you can see, the circle and the rectangle do not overlap, and this can be shown by the distance between the center of the circle and the closest edge of the rectangle.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/circle-and-rectangle-overlapping/">1401. Circle and Rectangle Overlapping</a></p>
<p><strong>The Main Idea</strong></p>
<p>The idea of this solution is to find the distance from the middle of the circle to the edge of a rectangle, and if the distance is smaller than or equal to the radius, we know that the rectangle overlaps with the circle.</p>
<p>If you don&rsquo;t understand, look at the following images:</p>
<p><img src="https://i.imgur.com/VlNe79P.jpg" alt=""></p>
<blockquote>
<p>As you can see, the circle and the rectangle do not overlap, and this can be shown by the distance between the center of the circle and the closest edge of the rectangle. The length is <code>8 = 2.82842712474619</code>, <code>2.82842712474619</code> is greater than the radius of <code>1</code>, so we know that the circle and the rectangle don&rsquo;t overlap.</p>
</blockquote>
<p><img src="https://i.imgur.com/W6g3aVq.jpg" alt=""></p>
<blockquote>
<p>In the image above, we can see that the circle and the edge of the rectangle overlaps. And we can see that the distance between the closest edge of the square and the center of the circle is equal to the radius, so we can see that the rectangle and the rectangle overlap.</p>
</blockquote>
<p><img src="https://i.imgur.com/h8vdUkm.jpg" alt=""></p>
<blockquote>
<p>In the image above, we can see that the circle and the rectangle overlap. The distance between the center of the circle and the closest point on the rectangle is <code>5 = 2.23606797749979</code> and <code>2.23606797749979 &lt; radius</code> because <code>radius = 3</code>. Since the distance is smaller than the <code>radius</code>, we can say that the two shapes overlap.</p>
</blockquote>
<p><strong>How It Works:</strong></p>
<p>Now that we have covered the main idea of this function, we can get into the details.</p>
<p><strong>The first part is:</strong></p>
<pre><code>if x_center &lt; x2 &amp;&amp; x_center &gt; x1 &amp;&amp; y_center &lt; y2 &amp;&amp; y_center &gt; y1 {
    return true
}
</code></pre><p>The part above is for if the circle inside the square. Such as like:</p>
<p><img src="https://i.imgur.com/ChoNOLK.jpg" alt=""></p>
<p>As you can see, the circle radius is smaller than the distance of the closest edge and the center of the circle. We know that the circle and the rectangle overlap, but the computer thinks that they don&rsquo;t overlap because the <code>distance from the center of the circle to the edge of the rectangle &gt; radius</code>, so we have to make sure that this is counted as an overlap. We check whether this is overlap by checking whether the center of the circle is between the two x&rsquo;s and between the two y&rsquo;s.</p>
<p><strong>The next part:</strong></p>
<pre><code>if ((y1 &lt;= y_center+radius &amp;&amp; y1 &gt;= y_center) ||
    (y2 &gt;= y_center-radius &amp;&amp; y2 &lt;= y_center)) &amp;&amp; x_center &gt;= x1 &amp;&amp;
    x_center &lt;= x2 {
    
    return true
}
</code></pre><p>This can be used for something like the example below:</p>
<p><img src="https://i.imgur.com/5T1fXOG.jpg" alt=""></p>
<p>The main idea of:</p>
<p><code>((y1 &lt;= y_center+radius &amp;&amp; y1 &gt;= y_center) || (y2 &gt;= y_center-radius &amp;&amp; y2 &lt;= y_center)) &amp;&amp; x_center &gt;= x1 &amp;&amp; x_center &lt;= x2</code></p>
<p>is:</p>
<p><code>(y1 &lt;= y_center + radius || y2 &gt;= y_center - radius) &amp;&amp; x_center &gt;= x1 &amp;&amp; x_center &lt;= x2</code></p>
<p>Then after that, we can start to understand the additional parts.</p>
<p>First, <code>y1 &lt;= y_center + radius</code> is for if the circle is beneath the rectangle, just like the image below.</p>
<p><img src="https://i.imgur.com/8YwF90u.jpg" alt=""></p>
<p><code>y1 &lt;= y_center + radius</code> in this example is <code>6 &lt;= 5 + 2</code> which equals <code>6 &lt;= 7</code>. So for this example the <code>y</code>&rsquo;s' overlap.</p>
<p><code>y2 &gt;= y_center - radius</code> is for when the circle is on top of the rectangle like in the picture below:</p>
<p><img src="https://i.imgur.com/NjPtHcc.jpg" alt=""></p>
<p><code>y2 &gt;= y_center - radius</code> in this example is <code>4 &gt;= 6 - 2</code> which is <code>4 = 4</code>. As we can see the <code>y</code>&rsquo;s' overlap.</p>
<p>The next part, <code>x_center &gt;= x1 &amp;&amp; x_center &lt;= x2</code> is for checking whether the center of the circle is inside the <code>x</code>&rsquo;s values of the rectangle, so we can use the example above again.</p>
<p>As we said before the <code>y</code> parts of the shapes overlap. And now we can see that <code>x_center = 8</code>. <code>8 &gt; 5</code>, <code>x1 = 5</code>, and <code>8 &lt; 10</code>, and <code>x2 = 8</code>.</p>
<p>We can see an example where the <code>y</code> parts overlap, but the <code>x</code>&rsquo;s parts don&rsquo;t.</p>
<p><img src="https://i.imgur.com/vTe00bX.jpg" alt=""></p>
<p>The <code>y</code> parts work, <code>y2 &gt;= y_center - radius</code>, which equals <code>4 &gt;= 5 - 2</code> and when simplifyed <code>4 &gt;= 3</code>. But the <code>x</code> parts don&rsquo;t work because the equations are <code>x_center &gt;= x1</code> and <code>x_center &lt;= x2</code>, and when we put in our numbers we get <code>13 &gt;= 5</code> but when we put in the numbers into the second equation, <code>13 &gt; 10</code> while we want <code>x_center &lt;= x2</code>. So we know that the shapes don&rsquo;t overlap.</p>
<p>It also checks whether <code>y1 &gt;= y_center</code> and <code>y2 &lt;= y_center</code> because we want to make sure that we don&rsquo;t <code>return true</code> for extra test cases.</p>
<p><strong>The Next Part:</strong></p>
<pre><code>if y_center &lt;= y2 &amp;&amp; y_center &gt;= y1 &amp;&amp; ((x_center-radius &lt;= x2 &amp;&amp; 
    x_center &gt;= x2) || (x_center+radius &gt;= x1 &amp;&amp; x_center &lt;= x1)) {
    
    return true
}
</code></pre><p>We use this part if the part before fails. This checks whether the circle is on either side of the rectangle.</p>
<p>This checks whether the <code>y_center</code> is greater than or equal to <code>y1</code> and if it is smaller than or equal to <code>y2</code>. Then it checks whether the <code>x_center - radius</code> is smaller than or equal to <code>x2</code>, or <code>x_center - radius &gt;= x1</code>. It also checks whether <code>x_center &gt;= x2</code> and <code>x_center &lt;= x1</code>, just like the previous part.</p>
<p>We can explain this with the following images:</p>
<p><img src="https://i.imgur.com/PyTQ1SK.jpg" alt=""></p>
<p>This circle is on the right of the rectangle.</p>
<p>We can see that the <code>y_center = 4</code> and <code>4 &lt; 7</code>, <code>y2 = 7</code>, and <code>4 &gt; 1</code>, <code>y1 = 1</code>. We can see that <code>((x_center-radius &lt;= x2 &amp;&amp; x_center &gt;= x2) || (x_center+radius &gt;= x1 &amp;&amp; x_center &lt;= x1))</code> is true because <code>x_center-radius &lt;= x2 &amp;&amp; x_center &gt;= x2</code>, since <code>x_center = 4</code>, and that <code>radius = 2</code>. <code>4 - 2 &lt;= 3</code> and <code>4 &gt; 3</code> so we return true.</p>
<p>The next image is on the left of the image:</p>
<p><img src="https://i.imgur.com/6VIXcKh.jpg" alt=""></p>
<p>The <code>y</code> part is the same as the last image, so we know that the <code>y</code> part overlaps. So we can see that the <code>y</code> part overlaps. We can use the formula <code>x_center + radius &gt;= x1 &amp;&amp; x_center &lt;= x1</code>. <code>x_center = 3</code> and the <code>radius  = 2</code>. So when we input the numbers into the variables, <code>3 + 2 &gt;= 4</code> when simplifyed <code>5 &gt;= 4</code>, <code>x1 = 4</code>. The next equation is <code>3 &lt;= 4</code>.</p>
<p>As we can see <code>x_center+radius &gt;= x1 &amp;&amp; x_center &lt;= x1</code> is for if the circle is on the right of the rectangle. And <code>x_center-radius &lt;= x2 &amp;&amp; x_center &gt;= x2</code> is for if the circle is on the left of the rectangle.</p>
<p><strong>The last part:</strong></p>
<pre><code>if powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) &lt;= 
    powerOfTwo(radius) {
    
    return true
}
</code></pre><p>The idea of <code>powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) &lt;= powerOfTwo(radius)</code> is basicly pythagoras theorem, <code>a^2 + b^2 = c^2</code>. <code>a^2 + b^2 = c^2</code>, and this is basicly <code>(x_center - x1)^2 + (y_center - y1)^2 = radius^2</code>.</p>
<p>The distance formula is <code>d = sqrt((x1 - x2)^2 + (y1 - y2)^2)</code>, though for this problem we don&rsquo;t need the <code>sqrt</code> so we the equation can be <code>d = (x1 - x2)^2 + (y1 - y2)^2)</code>, so we can continue to use <code>(x_center - x1)^2 + (y_center - y1)^2 = radius^2</code>.</p>
<p>All of the following are similar except for different points, <code>x1, x2, y1, y2, x_center, y_center</code>.</p>
<pre><code>powerOfTwo(x_center-x1)+powerOfTwo(y_center-y2) &lt;= powerOfTwo(radius)

powerOfTwo(x_center-x2)+powerOfTwo(y_center-y1) &lt;= powerOfTwo(radius)

powerOfTwo(x_center-x2)+powerOfTwo(y_center-y2) &lt;= powerOfTwo(radius)
</code></pre><h2 id="the-code">The Code:</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">checkOverlap</span>(<span style="color:#a6e22e">radius</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">x_center</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y_center</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">x1</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y1</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">x2</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y2</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x_center</span> &lt; <span style="color:#a6e22e">x2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">x_center</span> &gt; <span style="color:#a6e22e">x1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">y_center</span> &lt; <span style="color:#a6e22e">y2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">y_center</span> &gt; <span style="color:#a6e22e">y1</span> {
        <span style="color:#75715e">// Checking whether the circle is in the middle of the square
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }

    <span style="color:#66d9ef">if</span> ((<span style="color:#a6e22e">y1</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">y_center</span><span style="color:#f92672">+</span><span style="color:#a6e22e">radius</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">y1</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">y_center</span>) <span style="color:#f92672">||</span>
    (<span style="color:#a6e22e">y2</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">y_center</span><span style="color:#f92672">-</span><span style="color:#a6e22e">radius</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">y2</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">y_center</span>)) <span style="color:#f92672">&amp;&amp;</span>
        <span style="color:#a6e22e">x_center</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">x1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">x_center</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">x2</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">y_center</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">y2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">y_center</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">y1</span> <span style="color:#f92672">&amp;&amp;</span> ((<span style="color:#a6e22e">x_center</span><span style="color:#f92672">-</span><span style="color:#a6e22e">radius</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">x2</span> <span style="color:#f92672">&amp;&amp;</span> 
    <span style="color:#a6e22e">x_center</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">x2</span>) <span style="color:#f92672">||</span> (<span style="color:#a6e22e">x_center</span><span style="color:#f92672">+</span><span style="color:#a6e22e">radius</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">x1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">x_center</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">x1</span>)) {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">x_center</span><span style="color:#f92672">-</span><span style="color:#a6e22e">x1</span>)<span style="color:#f92672">+</span><span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">y_center</span><span style="color:#f92672">-</span><span style="color:#a6e22e">y1</span>) <span style="color:#f92672">&lt;=</span> 
            <span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">radius</span>) <span style="color:#f92672">||</span>
        <span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">x_center</span><span style="color:#f92672">-</span><span style="color:#a6e22e">x1</span>)<span style="color:#f92672">+</span><span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">y_center</span><span style="color:#f92672">-</span><span style="color:#a6e22e">y2</span>) <span style="color:#f92672">&lt;=</span> 
            <span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">radius</span>) <span style="color:#f92672">||</span>
        <span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">x_center</span><span style="color:#f92672">-</span><span style="color:#a6e22e">x2</span>)<span style="color:#f92672">+</span><span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">y_center</span><span style="color:#f92672">-</span><span style="color:#a6e22e">y1</span>) <span style="color:#f92672">&lt;=</span> 
            <span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">radius</span>) <span style="color:#f92672">||</span>
        <span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">x_center</span><span style="color:#f92672">-</span><span style="color:#a6e22e">x2</span>)<span style="color:#f92672">+</span><span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">y_center</span><span style="color:#f92672">-</span><span style="color:#a6e22e">y2</span>) <span style="color:#f92672">&lt;=</span> 
            <span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">radius</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">powerOfTwo</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">n</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 836</title><link>https://nathannaveen.dev/posts/leetcode-836/</link><pubDate>Wed, 10 Mar 2021 12:10:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-836/</guid><description>836. Rectangle Overlap
This solution is pretty simular to my other solution Leetcode: 223 This is the part in the other solution which I based this solution on:
// A = rec1[0], B = rec1[1], C = rec1[2], D = rec1[3] // E = rec2[0], F = rec2[1], G = rec2[2], H = rec2[3] left, right := max(A, E), min(G, C) up, down := min(D, H), max(F, B) if right &amp;gt; left &amp;amp;&amp;amp; up &amp;gt; down { sum -= (right - left) * (up - down) // overlap } The idea of this solution can be shown using some images:</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/rectangle-overlap/">836. Rectangle Overlap</a></p>
<p>This solution is pretty simular to my other solution <a href="https://nathannaveen.dev/posts/leetcode-223/">Leetcode: 223</a> This is the part in the other solution which I based this solution on:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// A = rec1[0], B = rec1[1], C = rec1[2], D = rec1[3]
</span><span style="color:#75715e">// E = rec2[0], F = rec2[1], G = rec2[2], H = rec2[3]
</span><span style="color:#75715e"></span><span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">E</span>), <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">G</span>, <span style="color:#a6e22e">C</span>)
<span style="color:#a6e22e">up</span>, <span style="color:#a6e22e">down</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">D</span>, <span style="color:#a6e22e">H</span>), <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">F</span>, <span style="color:#a6e22e">B</span>)

<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">right</span> &gt; <span style="color:#a6e22e">left</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">up</span> &gt; <span style="color:#a6e22e">down</span> {
    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">-=</span> (<span style="color:#a6e22e">right</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">left</span>) <span style="color:#f92672">*</span> (<span style="color:#a6e22e">up</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">down</span>) <span style="color:#75715e">// overlap
</span><span style="color:#75715e"></span>}
</code></pre></div><p>The idea of this solution can be shown using some images:</p>
<p>We can get the input <code>[1, 1, 3, 3], [2, 2, 7, 6]</code> and graph it:</p>
<p><img src="https://i.imgur.com/xmXTUnU.jpg" alt=""></p>
<p><img src="https://i.imgur.com/vmxU1Ni.jpg" alt=""></p>
<p>And when the <code>left, right, up, down</code> lines are shown we get the overlap. We can find the <code>left, right, up, down</code> lines by doing the folowing:</p>
<ul>
<li><code>Left =</code> the maximum of <code>rec1 x1</code> and <code>rec2 x1</code>, and as you can see <code>rec2 x1</code> is <code>left</code> because it is greater than <code>rec1 x1</code></li>
<li><code>Right =</code> the minimum of <code>rec1 x2</code> and <code>rec2 x2</code>. As we can see <code>right</code> is <code>rec1 x1</code>.</li>
<li><code>Down =</code> the maximum of <code>rec1 y1</code> and <code>rec2 y1</code>. As we can also see the max is <code>rec2 y1</code>.</li>
<li><code>Up =</code> the minimum of <code>rec1 y2</code> and <code>rec2 y2</code>. Al we can see the min is <code>rec1 y2</code>.</li>
</ul>
<p>And now you can see that this is how we find whether there is an overlap.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isRectangleOverlap</span>(<span style="color:#a6e22e">rec1</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">rec2</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {

    <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">rec1</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">rec2</span>[<span style="color:#ae81ff">0</span>]), <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">rec1</span>[<span style="color:#ae81ff">2</span>], <span style="color:#a6e22e">rec2</span>[<span style="color:#ae81ff">2</span>])
    <span style="color:#a6e22e">up</span>, <span style="color:#a6e22e">down</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">rec1</span>[<span style="color:#ae81ff">3</span>], <span style="color:#a6e22e">rec2</span>[<span style="color:#ae81ff">3</span>]), <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">rec1</span>[<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">rec2</span>[<span style="color:#ae81ff">1</span>])

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">right</span> &gt; <span style="color:#a6e22e">left</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">up</span> &gt; <span style="color:#a6e22e">down</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>

}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#a6e22e">b</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#a6e22e">b</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 1750</title><link>https://nathannaveen.dev/posts/leetcode-1750/</link><pubDate>Tue, 09 Mar 2021 21:04:18 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1750/</guid><description>1750. Minimum Length of String After Deleting Similar Ends
The idea of this solution is pretty simple, so it can be shown with this image:
func minimumLength(s string) int { for len(s) &amp;gt; 1 &amp;amp;&amp;amp; s[0] == s[len(s)-1] { end := s[len(s)-1] lenS := len(s) for i := 0; i &amp;lt; lenS; i++ { if s[len(s)-1] != s[0] { s = s[:len(s)-i-1] break } } lenS = len(s) for i := 0; i &amp;lt; lenS; i++ { if s[0] !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/">1750. Minimum Length of String After Deleting Similar Ends</a></p>
<p>The idea of this solution is pretty simple, so it can be shown with this image:</p>
<p><img src="https://i.imgur.com/QAmU64G.jpg" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">minimumLength</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {

    <span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">s</span>) &gt; <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>[len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] {
        <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>[len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        <span style="color:#a6e22e">lenS</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">s</span>)

        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">lenS</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>[len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>] {
                <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[:len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                <span style="color:#66d9ef">break</span>
            }
        }
        <span style="color:#a6e22e">lenS</span> = len(<span style="color:#a6e22e">s</span>)
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">lenS</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> <span style="color:#a6e22e">end</span> {
                <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span><span style="color:#f92672">+</span><span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]
                <span style="color:#66d9ef">break</span>
            }
        }
    }

    <span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">s</span>)
}

</code></pre></div>]]></content></item><item><title>Leetcode 1752</title><link>https://nathannaveen.dev/posts/leetcode-1752/</link><pubDate>Tue, 09 Mar 2021 21:04:13 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1752/</guid><description>1752. Check if Array Is Sorted and Rotated
The idea of this solution is to loop through the array, and then check whether there is a nums[i] which is greater than nums[(i+1) % len(nums)] (By the way (i+1) % len(nums) is for getting the next number) if nums[i] &amp;gt; nums[(i+1)%len(nums)] then add one to a counter called counter. Then we check whether counter is greater than or equal to 2.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/">1752. Check if Array Is Sorted and Rotated</a></p>
<p>The idea of this solution is to loop through the array, and then check whether there is a <code>nums[i]</code> which is greater than <code>nums[(i+1) % len(nums)]</code> (By the way <code>(i+1) % len(nums)</code> is for getting the next number) if <code>nums[i] &gt; nums[(i+1)%len(nums)]</code> then add one to a counter called <code>counter</code>. Then we check whether <code>counter</code> is greater than or equal to <code>2</code>.</p>
<p>We check whether <code>counter</code>is greater than or eqal to <code>2</code> because if there are more than one <code>nums[i] &gt; nums[(i+1)%len(nums)]</code> we know that it is not sorted.</p>
<p><img src="https://i.imgur.com/v2Qpuls.jpg" alt=""></p>
<blockquote>
<p>This is sorted, we know because there is only one <code>nums[i] &gt; nums[(i+1)%len(nums)]</code>. The array is <code>[4, 5, 1, 2, 3]</code> and when we rotate it we get <code>[1, 2, 3, 4, 5]</code>.</p>
</blockquote>
<p><img src="https://i.imgur.com/SHE6tuZ.jpg" alt=""></p>
<blockquote>
<p>We we can see that the array <code>[2, 5, 1, 4, 3]</code> can never be rotated and be sorted:
<code>[5, 1, 4, 3, 2]</code>
<code>[1, 4, 3, 2, 5]</code>
<code>[4, 3, 2, 5, 1]</code>
<code>[3, 2, 5, 1, 4]</code>
<code>[2, 5, 1, 4, 3]</code></p>
<p>As you can see there is two <code>nums[i] &gt; nums[(i+1)%len(nums)]</code> so it will never be sorted.</p>
</blockquote>
<p><img src="https://i.imgur.com/1oHm0tT.jpg" alt=""></p>
<blockquote>
<p>The input is already sorted, but even without that we can see that there is only one <code>nums[i] &gt; nums[(i+1)%len(nums)]</code>.</p>
</blockquote>
<hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#a6e22e">counter</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">nums</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#a6e22e">nums</span>[(<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>len(<span style="color:#a6e22e">nums</span>)] {
            <span style="color:#a6e22e">counter</span><span style="color:#f92672">++</span>
        }
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span> {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
        }
    }

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div><p><strong>We could make the first solution a little better by doing:</strong> <em>(This is better because we are only checking the if when we add to counter and not every single time)</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#a6e22e">counter</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">nums</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#a6e22e">nums</span>[(<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>len(<span style="color:#a6e22e">nums</span>)] {
            <span style="color:#a6e22e">counter</span><span style="color:#f92672">++</span>
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span> {
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
            }
        }

    }

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 1784</title><link>https://nathannaveen.dev/posts/leetcode-1784/</link><pubDate>Mon, 08 Mar 2021 14:31:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1784/</guid><description>1784. Check if Binary String Has at Most One Segment of Ones
The problem description is:
Given a binary string s without leading zeros, return true if s contains at most one contiguous segment of ones. Otherwise, return false.
This is kind of hard to understand, so I am going to explain it. A contiguous segment of ones looks like:
111000 100 10 1 11110000 And some of the ones that are not contiguous are:</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/">1784. Check if Binary String Has at Most One Segment of Ones</a></p>
<p>The problem description is:</p>
<blockquote>
<p>Given a binary string <code>s</code> without leading zeros, return <code>true</code> if <code>s</code> contains at most one contiguous segment of ones. Otherwise, return <code>false</code>.</p>
</blockquote>
<p>This is kind of hard to understand, so I am going to explain it. A contiguous segment of ones looks like:</p>
<pre><code>111000
100
10
1
11110000
</code></pre><p>And some of the ones that are not contiguous are:</p>
<pre><code>101
1001
111001
10011
</code></pre><p>You should be able to see that the non-consecutive strings have a <code>&quot;01&quot;</code>. We have to check whether there is a <code>&quot;01&quot;</code> in the string. If so, return <code>false</code>.</p>
<p><em>Note: We don&rsquo;t have to worry about strings with leading zeros. That is why we can check whether there is a <code>&quot;01&quot;</code> in a string and return <code>false</code> if so. If we had leading zeros, there would be <code>&quot;01&quot;</code>&rsquo;s in the string even if there are consecutive ones, such as <code>&quot;001110&quot;</code>. We should return <code>true,</code> but there is a <code>&quot;01&quot;</code>.</em></p>
<p><strong>First Solution:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">checkOnesSegment</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>:<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;01&#34;</span> { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span> }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div><p><strong>Second Solution:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">checkOnesSegment</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span> }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 1332</title><link>https://nathannaveen.dev/posts/leetcode-1332/</link><pubDate>Mon, 08 Mar 2021 09:42:56 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1332/</guid><description>1332. Remove Palindromic Subsequences
This problem asks us to find all the subsequences in a string called s. s only contains the letters a and b.
When we are doing this problem, the main thing to look at is that it says &amp;ldquo;subsequences,&amp;rdquo; not &amp;ldquo;substrings,&amp;rdquo; and that there are only two letters a and b.
The difference between &amp;ldquo;substrings&amp;rdquo; and &amp;ldquo;subsequences&amp;rdquo; is substrings are consecutive letters, while subsequences doesn&amp;rsquo;t have to be consecutive.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-palindromic-subsequences/">1332. Remove Palindromic Subsequences</a></p>
<p>This problem asks us to find all the subsequences in a string called <code>s</code>. <code>s</code> only contains the letters <code>a</code> and <code>b</code>.</p>
<p>When we are doing this problem, the main thing to look at is that it says &ldquo;subsequences,&rdquo; not &ldquo;substrings,&rdquo; and that there are only two letters <code>a</code> and <code>b</code>.</p>
<p>The difference between &ldquo;substrings&rdquo; and &ldquo;subsequences&rdquo; is substrings are consecutive letters, while subsequences doesn&rsquo;t have to be consecutive.</p>
<p>Since we have the letters <code>a</code> and <code>b</code>, we can remove all the <code>a</code>&rsquo;s first and then remove all the <code>b</code>&rsquo;s.</p>
<p><strong>How This Works:</strong></p>
<p>First, we can have an example of an empty string <code>&quot;&quot;</code> and return <code>0</code> because the string is already empty.</p>
<p>Next, we can have the example of the input being a palindrome, <code>&quot;ababa&quot;</code>, we can return <code>1</code> because we get an empty string when we remove this palindrome.</p>
<p>Finally, we can return <code>2</code> because we first add all the <code>a</code>&rsquo;s together and remove that palindrome, then add all the <code>b</code>&rsquo;s together and remove that palindrome. This can be shown with the folowing example:</p>
<p><code>input = &quot;ababaab</code> <code>output = 2</code></p>
<p>The output is <code>2</code> because we remove the palindromic subsequence of <code>&quot;aaaa&quot;</code>. We get the letters at the indexes <code>0, 2, 4, 5</code>, and they make <code>&quot;aaaa&quot;</code>. Then for the second part, we remove the palindrome <code>&quot;bbb&quot;</code>. We get the palindrome <code>&quot;bbb&quot;</code> by getting the indexes <code>1, 3, 6</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">removePalindromeSub</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
    }
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">palindromic</span>(<span style="color:#a6e22e">s</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">palindromic</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">left</span> &lt; <span style="color:#a6e22e">right</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">left</span>] <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">right</span>] {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
        }

        <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> = <span style="color:#a6e22e">left</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">right</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
    }

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 915</title><link>https://nathannaveen.dev/posts/leetcode-915/</link><pubDate>Mon, 08 Mar 2021 08:20:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-915/</guid><description>The idea of this solution is to find the max of the left and then check whether the max is always smaller than all the rights. If it is smaller than all of them return the index (1 indexed).
This can be shown with a picture:
func partitionDisjoint(A []int) int { max := A[0] for i := 0; i &amp;lt; len(A); i++ { shouldReturn := true if max &amp;lt; A[i] { max = A[i] } for j := i + 1; j &amp;lt; len(A); j++ { if A[j] &amp;lt; max { shouldReturn = false break } } if shouldReturn { return i + 1 } } return -1 }</description><content type="html"><![CDATA[<p>The idea of this solution is to find the max of the left and then check whether the max is always smaller than all the rights. If it is smaller than all of them return the index <strong>(1 indexed)</strong>.</p>
<p>This can be shown with a picture:</p>
<p><img src="https://i.imgur.com/ZzXwU7p.jpg" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">partitionDisjoint</span>(<span style="color:#a6e22e">A</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">max</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">A</span>[<span style="color:#ae81ff">0</span>]

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">A</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">shouldReturn</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">true</span>

        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">max</span> &lt; <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">i</span>] {
            <span style="color:#a6e22e">max</span> = <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">i</span>]
        }
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span> &lt; len(<span style="color:#a6e22e">A</span>); <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">j</span>] &lt; <span style="color:#a6e22e">max</span> {
                <span style="color:#a6e22e">shouldReturn</span> = <span style="color:#66d9ef">false</span>
                <span style="color:#66d9ef">break</span>
            }
        }
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">shouldReturn</span> {
            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        }
    }

    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 973</title><link>https://nathannaveen.dev/posts/leetcode-973/</link><pubDate>Sun, 07 Mar 2021 10:43:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-973/</guid><description>973. K Closest Points to Origin
The New Distance Formula:
The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&amp;rsquo;t aline up when writen up in text)
This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&amp;rsquo;t need to be square rooted.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/k-closest-points-to-origin/">973. K Closest Points to Origin</a></p>
<p><strong>The New Distance Formula:</strong></p>
<p>The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&rsquo;t aline up when writen up in text)</p>
<p><img src="https://i.imgur.com/krhq25z.jpg" alt=""></p>
<p>This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&rsquo;t need to be square rooted. The distance not needing to be square rooted can be shown by doing an experiment, for example let us take the square root of 10 and the square root of 8, we know that the square root of 10 will allways be greater than the square root of 8. We also know that 10 will always be greater than 8. Try this with any two positive numbers. <em>Note: I said positve numbers because any square number is positive.</em></p>
<p>So now our equation for the distance is:</p>
<p><img src="https://i.imgur.com/U8tN3Zs.jpg" alt=""></p>
<p>We can simplify the equation again by taking out the x2 and the y2 because x2 and y2 will always be <code>0</code>. X2 and y2 will always be <code>0</code> because the first point is a regular point, but the second point will be <code>(0, 0)</code> because the second point will always be the origin. This can by shown by an example:</p>
<p><img src="https://i.imgur.com/sbAt4Eg.jpg" alt=""></p>
<p>So the new distance equation is:</p>
<p><img src="https://i.imgur.com/VDLMrjy.jpg" alt=""></p>
<hr>
<p><strong>The Idea Of This Solution:</strong></p>
<p>Now that we know that we know the distance formula for this problem is <code>x^2 + y^2</code> we just have to sort the matrix array.</p>
<p>The way we sort the array is we check whether the current distance is smaller than the the previous distance, then if so we switch the two points, then we move back a space, to check whether the previous value is greater than the current value. This can be show by the following example:</p>
<p><img src="https://i.imgur.com/CFPvZ2L.jpg" alt=""></p>
<p><img src="https://i.imgur.com/O4uLB9c.jpg" alt=""></p>
<p>We do nothing because <code>18 &lt; 26</code>. So we continue:</p>
<p><img src="https://i.imgur.com/n6q63xp.jpg" alt=""></p>
<p><code>26</code> is greater than <code>20</code> so we have to switch them. We also have to subtract <code>2</code> from <code>i</code>. <code>i</code> will only go back by <code>1</code> even though we subtract <code>2</code> from <code>i</code> because the for loop adds <code>1</code> to <code>i</code>.</p>
<p><img src="https://i.imgur.com/YhAlxxI.jpg" alt=""></p>
<p><code>18</code> is smaller than <code>20</code> so do nothing.</p>
<p><img src="https://i.imgur.com/KwfMZjn.jpg" alt=""></p>
<p><code>20</code> is smaller than <code>26</code> so do nothing again.</p>
<p><img src="https://i.imgur.com/fAbocNo.jpg" alt=""></p>
<p><code>26</code> is smaller than <code>130</code> so we do nothing again. Since <code>i</code> is at the end <code>points</code> is <code>[[3, 3], [-2, 4], [5, -1], [7, 9]]</code>.</p>
<hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">kClosest</span>(<span style="color:#a6e22e">points</span> [][]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">points</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> {
            <span style="color:#a6e22e">distanceOfIMinusOne</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>])
            <span style="color:#a6e22e">distanceOfI</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">1</span>])
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">distanceOfIMinusOne</span> &gt; <span style="color:#a6e22e">distanceOfI</span> {
                <span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>
            }
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">points</span>[:<span style="color:#a6e22e">k</span>]
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">n</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 1773</title><link>https://nathannaveen.dev/posts/leetcode-1773/</link><pubDate>Sat, 06 Mar 2021 19:06:10 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1773/</guid><description>1773. Count Items Matching a Rule
The idea of this solution is pretty simple. We know that the array items has only 3 items. The first one is the ruleKey = &amp;quot;type&amp;quot; the next one is ruleKey = &amp;quot;color&amp;quot;, and the next one is ruleKey = &amp;quot;name&amp;quot;. We just have to set a index of each item to either 0, 1 or 2. Then just loop over each item and check whether the item[index] == ruleValue.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/count-items-matching-a-rule/">1773. Count Items Matching a Rule</a></p>
<p>The idea of this solution is pretty simple. We know that the array <code>items</code> has only <code>3</code> items. The first one is the <code>ruleKey = &quot;type&quot;</code> the next one is <code>ruleKey = &quot;color&quot;</code>, and the next one is <code>ruleKey = &quot;name&quot;</code>. We just have to set a index of each item to either <code>0, 1</code> or <code>2</code>. Then just loop over each item and check whether the <code>item[index] == ruleValue</code>.</p>
<pre><code>func countMatches(items [][]string, ruleKey string, ruleValue string) int {
	res := 0
	index := 0
	if ruleKey == &quot;color&quot; {
		index = 1
	} else if ruleKey == &quot;name&quot; {
		index = 2
	}

	for _, item := range items {
		if item[index] == ruleValue {
			res++
		}
	}
	
	return res
}
</code></pre>]]></content></item><item><title>Leetcode 1779</title><link>https://nathannaveen.dev/posts/leetcode-1779/</link><pubDate>Sat, 06 Mar 2021 19:05:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1779/</guid><description>1779. Find Nearest Point That Has the Same X or Y Coordinate
What The Problem Is Asking:
This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called points.
The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/">1779. Find Nearest Point That Has the Same X or Y Coordinate</a></p>
<p><strong>What The Problem Is Asking:</strong></p>
<p>This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called <code>points</code>.</p>
<p>The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</p>
<p>Then the problem asks you to return the index of the minimum distance. If there is no point that has the same x value or the save y value <code>return -1</code>.</p>
<p>The Manhattan distance is the distance between two points by doing <code>abs(y1 - y2) + abs(x1 - x2)</code>.</p>
<p><strong>How The Solution Works:</strong></p>
<p>The main idea of this solution is that the problem asks to find the Manhattan distance of the points that have the same x or y value.</p>
<p><em>The reason this is so important can be shown using an image:</em></p>
<p>The average 2 points that don&rsquo;t have the same x value or y value can by shown by this image:</p>
<p><img src="https://i.imgur.com/9VP0fWS.jpg" alt=""></p>
<p>This is for two points that have the same x value:</p>
<p><img src="https://i.imgur.com/ppluacv.jpg" alt=""></p>
<blockquote>
<p>When the two <code>x</code> values are the same we just have to calculate the <code>y</code> part because when we subtract both the <code>x</code> parts we get <code>0</code>. This can be shown by the image above <code>(4 - 2) + (3 - 3) = 2 + 0 = 2</code>. The part <code>(4 - 2)</code> is the part that follows the <code>y</code> axis, and the part <code>(3 - 3)</code> is the <code>x</code> part.</p>
</blockquote>
<p>This is for two points that have the same y value:</p>
<p><img src="https://i.imgur.com/u4sdUZO.jpg" alt=""></p>
<blockquote>
<p>When both <code>y</code>&rsquo;s are equal then the <code>y</code> part will be equal to zero so we wont have to calculate the <code>y</code> part. This can be show by the above example, <code>(1 - 1) + (4 - 1) = 3</code>. The <code>y</code> part <code>(1 - 1) = 0</code>.</p>
</blockquote>
<p>So, when a point in the array has a <code>x</code> value equal to the given <code>x</code> value just calculate the <code>y</code> part. And when the <code>y</code> part of a point in the array is eqal to the given <code>y</code> value just calculate the <code>x</code> part.</p>
<p><strong>Extra Notes:</strong></p>
<p>This solution doesn&rsquo;t use a build in <code>math.Abs()</code> function because it would take longer to process than using a self made absolute function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">nearestValidPoint</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">points</span> [][]<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">minimum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">100000000</span> <span style="color:#75715e">// the max value has to be 10^4 * 10^4 = 10^8
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 10^8 = 100,000,000
</span><span style="color:#75715e"></span>    
    <span style="color:#a6e22e">resIndex</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">point</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">points</span> {
        <span style="color:#a6e22e">manhattanYAbs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">absoluteValue</span>(<span style="color:#a6e22e">point</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#a6e22e">y</span>)
        <span style="color:#a6e22e">manhattanXAbs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">absoluteValue</span>(<span style="color:#a6e22e">point</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> <span style="color:#a6e22e">x</span>)
        
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">point</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">manhattanYAbs</span> &lt; <span style="color:#a6e22e">minimum</span> {
            <span style="color:#a6e22e">minimum</span> = <span style="color:#a6e22e">manhattanYAbs</span>
            <span style="color:#a6e22e">resIndex</span> = <span style="color:#a6e22e">i</span>
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">point</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">manhattanXAbs</span> &lt; <span style="color:#a6e22e">minimum</span> {
            <span style="color:#a6e22e">minimum</span> = <span style="color:#a6e22e">manhattanXAbs</span>
            <span style="color:#a6e22e">resIndex</span> = <span style="color:#a6e22e">i</span>
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">resIndex</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">absoluteValue</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &lt; <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">n</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 223</title><link>https://nathannaveen.dev/posts/leetcode-223/</link><pubDate>Fri, 05 Mar 2021 11:04:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-223/</guid><description>223. Rectangle Area
The main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them.
If you don&amp;rsquo;t understand the ABCDRectangle and the EFGHRectangle then look at the following images:
We can have the example:
Let us start of with the ABCDRectangle:
When we do the equation (D - B) * (C - A) we are basicly doing width * length.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/rectangle-area/">223. Rectangle Area</a></p>
<p>The main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them.</p>
<p>If you don&rsquo;t understand the <code>ABCDRectangle</code> and the <code>EFGHRectangle</code> then look at the following images:</p>
<p><strong>We can have the example:</strong></p>
<p><img src="https://i.imgur.com/St26i3w.jpg" alt=""></p>
<p>Let us start of with the <code>ABCDRectangle</code>:</p>
<p><img src="https://i.imgur.com/Td0G3vB.jpg" alt=""></p>
<p>When we do the equation <code>(D - B) * (C - A)</code> we are basicly doing <code>width * length</code>. The <code>width</code> is <code>(D - B)</code>. This can be show by using the image above where <code>A = -4, B = 2, C = 4, D = 5</code>. When we do <code>(D - B)</code> it equal <code>(5 - 2) = 3</code>. So we know that the rectangle has a width of <code>3</code>.</p>
<p>Now the <code>length</code> is going to be <code>(C - A)</code> which is equal to <code>(4 - (-4)) = (4 + 4) = 8</code>. Since we already know the width, and we know the height we can put them together. <code>width * height = 3 * 8 = 24</code>. The area of this rectangle is <code>24</code>.</p>
<p>Next let us do <code>EFGHRectangle</code>:</p>
<p><img src="https://i.imgur.com/D1uXC5Q.jpg" alt=""></p>
<p>This is pretty much the same as the <code>ABCDRectangle</code>. The equation <code>(H - F) * (G - E) = width * length</code>. As you can see in the image <code>E = 3, F = -2, G = 7, H = 8</code>. When we input the numbers in for the variables we get <code>(H - F) = (8 - (-2)) = (8 + 2) = 10</code>, so our width is <code>10</code>.</p>
<p>We can do the same thing but with length, The part of the equation that is for length is <code>(G - E)</code> when we input the numbers in for the variables we get <code>(7 - 3) = 4</code>. So we have a length of <code>4</code>.</p>
<p>When we multiply our width and our length together we get <code>10 * 4 = 40</code> so we have an area of <code>40</code>.</p>
<p>When we put both rectangles together we get:</p>
<p>Since we have an area of <code>24</code> for <code>ABCDRectangle</code> and an area of <code>40</code> for <code>EFGHRectangle</code>, when we add them up we get an area of <code>64</code>. The only problem is we have some over lap (Which I have colored purple in the image). We need to subtract the overlap from the total area.</p>
<p><img src="https://i.imgur.com/GBuwLLv.jpg" alt=""></p>
<p>The overlap is a rectangle as well so we know that it has two part, <code>length</code> and <code>width</code>. The idea of this part is the find the length and the width and then multiply them together and subtract that product from the total area.</p>
<p>I made four variables to find out where the overlap is, <code>left, right, up , down</code>. Left is the max of <code>A</code> and <code>E</code>. In this example the max is <code>E</code>, and it is the left side of the rectangle. The right is the min of <code>G</code> and <code>C</code>. In this example <code>C</code> is the minimum. Up is the minumum of <code>D</code> and <code>H</code>. <code>D</code> is smaller than <code>H</code> so up is <code>D</code>. Down is the max of <code>F</code> and <code>B</code>. <code>B</code> is greater than <code>F</code> so down is <code>B</code>.</p>
<p>Since we know that <code>left = E, right = C, up = D, down = B</code>, also we know that <code>A = -4, B = 2, C = 4, D = 5, E = 3, F = -2, G = 7, H = 8</code> so we can put those values in for their variables. <code>left = 3, right = 4, up = 5, down = 2</code>.</p>
<p>Before we even make the over lap rectangle we have to check whether there is a overlap rectangle. So we do <code>right &gt; left</code> because that means the right pointer is greater than the left pointer, and that there is not a negative area. Next it checks whether <code>up &gt; down</code> for the same reason that there is no negative area.</p>
<p>Now we can make a rectangle using these values and then subtract that rectangle from the total area. The length will be <code>(right - left) = (4 - 3) = 1</code>, and the width will be <code>(up - down) = (5 - 2) = 3</code>. Since we know that the area of a rectangle is <code>length * width</code> we can do <code>1 * 3 = 3</code>.</p>
<p>Now we can just subtract the area of the overlaping rectangle from the total area which is <code>64 - 3 = 61</code>. Now we know that our answer is 61.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">computeArea</span>(<span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">C</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">D</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">E</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">F</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">G</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">H</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">ABCDRectangle</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">D</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">B</span>) <span style="color:#f92672">*</span> (<span style="color:#a6e22e">C</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">A</span>) <span style="color:#75715e">// the first square
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">EFGHRectangle</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">H</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">F</span>) <span style="color:#f92672">*</span> (<span style="color:#a6e22e">G</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">E</span>) <span style="color:#75715e">// the second square
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ABCDRectangle</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">EFGHRectangle</span>

    <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">E</span>), <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">G</span>, <span style="color:#a6e22e">C</span>)
    <span style="color:#a6e22e">up</span>, <span style="color:#a6e22e">down</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">D</span>, <span style="color:#a6e22e">H</span>), <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">F</span>, <span style="color:#a6e22e">B</span>)

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">right</span> &gt; <span style="color:#a6e22e">left</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">up</span> &gt; <span style="color:#a6e22e">down</span> {
        <span style="color:#a6e22e">sum</span> <span style="color:#f92672">-=</span> (<span style="color:#a6e22e">right</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">left</span>) <span style="color:#f92672">*</span> (<span style="color:#a6e22e">up</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">down</span>) <span style="color:#75715e">// overlap
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#a6e22e">b</span> {<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>}
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#a6e22e">b</span> {<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>}
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 908</title><link>https://nathannaveen.dev/posts/leetcode-908/</link><pubDate>Thu, 04 Mar 2021 15:47:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-908/</guid><description>908. Smallest Range I
func smallestRangeI(A []int, K int) int { max, min := A[0], A[0] for _, i := range A { if i &amp;gt; max {max = i} if i &amp;lt; min {min = i} } if max-min-2*K &amp;gt; 0 { return max - min - 2 * K } return 0 }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/smallest-range-i/">908. Smallest Range I</a></p>
<pre><code>func smallestRangeI(A []int, K int) int {
	max, min := A[0], A[0]

	for _, i := range A {
		if i &gt; max {max = i}
		if i &lt; min {min = i}
	}
	if max-min-2*K &gt; 0 {
		return max - min - 2 * K
	}
	return 0
} 
</code></pre>]]></content></item><item><title>Leetcode 347</title><link>https://nathannaveen.dev/posts/leetcode-347/</link><pubDate>Thu, 04 Mar 2021 15:47:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-347/</guid><description>347. Top K Frequent Elements
The idea of this solution is pretty simple. First, add all the numbers to a matrix array with the size [number of different elements][2]. Then sort the array, and then add the values to a regular array of size K.
The matrix array has a size of [number of different elemtnets][2] because we need to add every element to its corresponding place in the array and then update the frequency by adding one to it.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></p>
<p>The idea of this solution is pretty simple. First, add all the numbers to a matrix array with the size <code>[number of different elements][2]</code>. Then sort the array, and then add the values to a regular array of size <code>K</code>.</p>
<hr>
<p>The matrix array has a size of <code>[number of different elemtnets][2]</code> because we need to add every element to its corresponding place in the array and then update the frequency by adding one to it. The array is put in the format <code>[frequency][number]</code>.</p>
<hr>
<p>This array is sorted by frequency first and then the number. When we sort, we check whether the frequency of the last number is smaller than the frequency of the current number. If so, then switch the two items, and subtract <code>2</code> from the counter.</p>
<hr>
<p><strong>The sort can be shown using these images:</strong></p>
<p><img src="https://i.imgur.com/fcBnUG3.jpg" alt=""></p>
<p><img src="https://i.imgur.com/GQeJ16L.jpg" alt=""></p>
<blockquote>
<p>[color=#0000ff] The frequency of the previous index is smaller than the current index, so switch them and subtract <code>2</code> from the index.</p>
</blockquote>
<p><img src="https://i.imgur.com/CyCoaX4.jpg" alt=""></p>
<blockquote>
<p>[color=#0000ff] Even though we subtract <code>2</code> from the index, we only go back <code>1</code> place because we add <code>1</code> to the index with the for loop.</p>
<p>Since the index is at zero, which is smaller than <code>1</code>, we don&rsquo;t do anything. We can&rsquo;t check whether the current index&rsquo;s frequency is smaller than the previous index&rsquo;s frequency because there is no previous index.</p>
</blockquote>
<p><img src="https://i.imgur.com/KYCWTms.jpg" alt=""></p>
<blockquote>
<p>[color=#0000ff] We don&rsquo;t do anything because the frequency of the previous number is greater than the current frequency.</p>
</blockquote>
<p><img src="https://i.imgur.com/zRoioun.jpg" alt=""></p>
<blockquote>
<p>[color=#0000ff] We still don&rsquo;t do anything because the previous frequency is greater than the current frequency. Since this is the last index, we know that <code>arr = [[4, 1], [2, 3], [1, 2]]</code> with the greatest frequency at the beginning and the smallest frequencies at the end.</p>
</blockquote>
<hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">topKFrequent</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> [][]<span style="color:#66d9ef">int</span>{}

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
        <span style="color:#a6e22e">contains</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
        
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ints</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">arr</span> {
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ints</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">num</span> {
                <span style="color:#a6e22e">ints</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">++</span>
                <span style="color:#a6e22e">contains</span> = <span style="color:#66d9ef">true</span>
                <span style="color:#66d9ef">break</span>
            }
        }
        
        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">contains</span> {
            <span style="color:#a6e22e">arr</span> = append(<span style="color:#a6e22e">arr</span>, []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">num</span>})
        }
    }

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">arr</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] &lt; <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">0</span>] {
            <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>]
            <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>
        }
    }

    <span style="color:#a6e22e">nums</span> = []<span style="color:#66d9ef">int</span>{}
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">k</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">nums</span> = append(<span style="color:#a6e22e">nums</span>, <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">1</span>])
    }

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nums</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 833</title><link>https://nathannaveen.dev/posts/leetcode-833/</link><pubDate>Thu, 04 Mar 2021 10:24:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-833/</guid><description>833. Find And Replace in String
func findReplaceString(S string, indexes []int, sources []string, targets []string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; len(S); i++ { index := 0 // this is the index that is used for indexes, sources, and targets for i2, i3 := range indexes { if i3 == i { index = i2 // we do this because the indexes are not sorted } } if index &amp;lt; len(indexes) &amp;amp;&amp;amp; i == indexes[index] { currentString := sources[index] isSubstring := true for i2 := range currentString { // checking whether the whole substring is equal if string(S[i+i2]) !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-and-replace-in-string/">833. Find And Replace in String</a></p>
<pre><code>func findReplaceString(S string, indexes []int, sources []string, targets []string) string {
	res := &quot;&quot;

	for i := 0; i &lt; len(S); i++ {
		index := 0 // this is the index that is used for indexes, sources, and targets

		for i2, i3 := range indexes {
			if i3 == i {
				index = i2 // we do this because the indexes are not sorted
			}
		}

		if index &lt; len(indexes) &amp;&amp; i == indexes[index] {
			currentString := sources[index]
			isSubstring := true
			for i2 := range currentString { // checking whether the whole substring is equal
				if string(S[i+i2]) != string(currentString[i2]) { 
					isSubstring = false
					break
				}
			}

			if isSubstring {
				res += targets[index]
				i += len(currentString) - 1 // we have to add to i because we dont want to repeat characters
			} else {
				res += string(S[i]) // if there is not a whole substring just add the character
			}
			index++
		} else {
			res += string(S[i]) // if there is no index in indexes that works for the current index
		}
	}

	return res
}

</code></pre>]]></content></item><item><title>Leetcode 1636</title><link>https://nathannaveen.dev/posts/leetcode-1636/</link><pubDate>Wed, 03 Mar 2021 16:02:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1636/</guid><description>1636. Sort Array by Increasing Frequency
The main idea of both the solutions is to add all the numbers to a matrix of lengths [len(nums)][2] and then sort each frequency of numbers by the max frequency. Suppose two values have the same frequency sort them by the value in descending order. After they are sorted, add all the values back to nums and return nums.
This is the sort:
for i := 1; i &amp;lt; len(arr); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; ((arr[i-1][0] &amp;gt; arr[i][0]) || (arr[i-1][0] == arr[i][0] &amp;amp;&amp;amp; arr[i-1][1] &amp;lt; arr[i][1])) { arr[i], arr[i-1] = arr[i-1], arr[i] i -= 2 } } The idea of it is to start at the second item (first if 0 indexed) and then check whether the frequency of the number before the current is greater than the frequency of the current number.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/sort-array-by-increasing-frequency/">1636. Sort Array by Increasing Frequency</a></p>
<p>The main idea of both the solutions is to add all the numbers to a matrix of lengths <code>[len(nums)][2]</code> and then sort each frequency of numbers by the max frequency. Suppose two values have the same frequency sort them by the value in descending order. After they are sorted, add all the values back to <code>nums</code> and return <code>nums</code>.</p>
<p><strong>This is the sort:</strong></p>
<pre><code>for i := 1; i &lt; len(arr); i++ {
    if i &gt;= 1 &amp;&amp; ((arr[i-1][0] &gt; arr[i][0]) || 
    (arr[i-1][0] == arr[i][0] &amp;&amp; arr[i-1][1] &lt; arr[i][1])) {
        arr[i], arr[i-1] = arr[i-1], arr[i]
        i -= 2
    }
}
</code></pre><p>The idea of it is to start at the second item (first if 0 indexed) and then check whether the frequency of the number before the current is greater than the frequency of the current number. This is show like this in the code: <code>((arr[i-1][0] &gt; arr[i][0])</code>. Or it checks whether the frequency is the same and whether the current number is greater than the number before the current number, this is show in the code as this: <code>arr[i-1][0] == arr[i][0] &amp;&amp; arr[i-1][1] &lt; arr[i][1]</code>. If either of these things is true, then switch the current and number before the current element and subtracts <code>2</code> from <code>i</code>. We subtract <code>2</code> from <code>i</code> to move back if we have to switch the next current and number before the current numbers. And we subtract <code>2</code>, not <code>1</code> because the loops <code>i++</code> cancel out one of the subtracts. Since we have an <code>i -= 2</code>, we have to check whether <code>i &gt;= 1</code> because if we don&rsquo;t and <code>i == 0</code>, we would have an out-of-bounds exception.</p>
<p>If you dont understand the explaination look at these images:</p>
<p><img src="https://i.imgur.com/2zecuOJ.jpg" alt="">
<img src="https://i.imgur.com/ZoBc0N6.jpg" alt="">
<img src="https://i.imgur.com/FFnnfj8.jpg" alt=""></p>
<p>The second code has better space complexity because, in the first solution, we use a <code>map</code> of size <code>len(nums)</code> and an <code>array</code> of size <code>[len(nums)][2]</code>. In the second solution, we just use an <code>array</code> of size <code>[len(nums)][2]</code>.</p>
<p><strong>Code One:</strong></p>
<pre><code>func frequencySort(nums []int) []int {
    m := make(map[int]int)
    arr := [][]int{}
    counter := 0

    for _, num := range nums {
        m[num]++
    }
    for i, i2 := range m {
        arr = append(arr, []int{i2, i})
    }

    for i := 1; i &lt; len(arr); i++ {
        if i &gt;= 1 &amp;&amp; ((arr[i-1][0] &gt; arr[i][0]) || 
        (arr[i-1][0] == arr[i][0] &amp;&amp; arr[i-1][1] &lt; arr[i][1])) {
            arr[i], arr[i-1] = arr[i-1], arr[i]
            i -= 2
        }
    }

    for i := 0; i &lt; len(arr); i++ {
        for j := 0; j &lt; arr[i][0]; j++ {
            nums[counter] = arr[i][1]
            counter++
        }
    }

    return nums
}
</code></pre><p><strong>Code Two:</strong></p>
<pre><code>func frequencySort(nums []int) []int {
    arr := [][]int{}
    counter := 0

    for _, num := range nums {
        contains := false

        for _, ints := range arr {
            if ints[1] == num {
                ints[0]++
                contains = true
                break
            }
        }

        if !contains {
            arr = append(arr, []int{1, num})
        }
    }

    for i := 1; i &lt; len(arr); i++ {
        if i &gt;= 1 &amp;&amp; ((arr[i-1][0] &gt; arr[i][0]) ||
        (arr[i-1][0] == arr[i][0] &amp;&amp; arr[i-1][1] &lt; arr[i][1])) {
            arr[i], arr[i-1] = arr[i-1], arr[i]
            i -= 2
        }
    }

    for i := 0; i &lt; len(arr); i++ {
        for j := 0; j &lt; arr[i][0]; j++ {
            nums[counter] = arr[i][1]
            counter++
        }
    }

    return nums
}
</code></pre>]]></content></item><item><title>Leetcode 1385</title><link>https://nathannaveen.dev/posts/leetcode-1385/</link><pubDate>Wed, 03 Mar 2021 13:25:26 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1385/</guid><description>1385. Find the Distance Value Between Two Arrays
The idea of this solution is to iterate through arr1 and then inside each iteration iterate through arr2. If the absolute value of arr1[i] - arr2[j] is smaller than or equal to d, we know that arr1[i] can&amp;rsquo;t be added to the resulting counter, so we can just break from the loop.
There is a abs function because math.Abs takes longer. When using math.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-the-distance-value-between-two-arrays/">1385. Find the Distance Value Between Two Arrays</a></p>
<p>The idea of this solution is to iterate through <code>arr1</code> and then inside each iteration iterate through <code>arr2</code>. If the absolute value of <code>arr1[i] - arr2[j]</code> is smaller than or equal to <code>d</code>, we know that <code>arr1[i]</code> can&rsquo;t be added to the resulting counter, so we can just <code>break</code> from the loop.</p>
<p>There is a abs function because <code>math.Abs</code> takes longer. When using <code>math.Abs</code> we have to make <code>float64(arr1[i] - arr2[j])</code>, and then make the <code>int(math.Abs)</code>.</p>
<pre><code>func findTheDistanceValue(arr1 []int, arr2 []int, d int) int {
    res := 0
    shouldAdd := true
    for i := 0; i &lt; len(arr1); i++ {
        for j := 0; j &lt; len(arr2); j++ {
            if abs(arr1[i]-arr2[j]) &lt;= d {
                shouldAdd = false
                break
            }
        }
        if shouldAdd {res++} else {shouldAdd = true}
    }
    return res
}

func abs(n int) int {
    if n &lt; 0 {
        return -n
    }
    return n
}
</code></pre>]]></content></item><item><title>Leetcode 645</title><link>https://nathannaveen.dev/posts/leetcode-645/</link><pubDate>Tue, 02 Mar 2021 11:27:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-645/</guid><description>645. Set Mismatch
The idea of this solution is to add every number in the array nums to another array called temp. Next we go through the array temp and check whether the number of a certain number is equal to 2, if it is then we know that it is the repeated number. If it is not 2 but it is 0 we know that it is the skiped number.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/set-mismatch/">645. Set Mismatch</a></p>
<p>The idea of this solution is to add every number in the array <code>nums</code> to another array called <code>temp</code>. Next we go through the array temp and check whether the number of a certain number is equal to <code>2</code>, if it is then we know that it is the repeated number. If it is not <code>2</code> but it is <code>0</code> we know that it is the skiped number. We know that there is always a duplicate number, so if we found the duplicate but not the value that is skiped we return the duplicate and the duplicate plus one, because if the skiped is not inside the array we have to return the next number.</p>
<p><code>temp</code> has <code>10001</code> values because the constraints of the problem say <code>2 &lt;= nums.length &lt;= 10^4, 1 &lt;= nums[i] &lt;= 10^4</code>, since <code>10^4</code> equals <code>10000</code> and the constraints say <code>nums.length &lt;= 10^4</code> we have to do <code>10^4 + 1 = 10000 + 1 = 10001</code>.</p>
<pre><code>func findErrorNums(nums []int) []int {
    sort.Ints(nums)
    double, skip := 0, 0
    temp := make([]int, 10001)

    for _, num := range nums {
        temp[num]++
    }

    for i, value := range temp {
        if value == 2 {
            double = i
            if skip != 0 {return []int{double, skip}}
        } else if value == 0 {
            skip = i
            if double != 0 {return []int{double, skip}}
        }
    }

    return []int{double, double + 1}
}
</code></pre>]]></content></item><item><title>Leetcode 34</title><link>https://nathannaveen.dev/posts/leetcode-34/</link><pubDate>Tue, 02 Mar 2021 11:27:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-34/</guid><description>34. Find First and Last Position of Element in Sorted Array
Both of the solutions use a two pointer approche. The first solution is slower than the second solution because it checks an extra if statment inside the loop, while the second solution checks it outside of the loop.
func searchRange(nums []int, target int) []int { left := 0 right := len(nums) - 1 for left &amp;lt; right { if nums[left] !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></p>
<p>Both of the solutions use a two pointer approche. The first solution is slower than the second solution because it checks an extra <code>if</code> statment inside the loop, while the second solution checks it outside of the loop.</p>
<pre><code>func searchRange(nums []int, target int) []int {
    left := 0
    right := len(nums) - 1

    for left &lt; right {
        if nums[left] != target {
            left++
        }
        if nums[right] != target {
            right--
        }
        if nums[left] == target &amp;&amp; nums[right] == target {
            return []int{left, right}
        }
    }

    if len(nums) &gt; 0 &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target {
        return []int{left, right}
    }

    return []int{-1, -1}
}
</code></pre><pre><code>func searchRange(nums []int, target int) []int {
    left := 0
    right := len(nums) - 1

    for (left &lt; right) &amp;&amp; (nums[left] != target || nums[right] != target) {
        if nums[left] != target {
            left++
        }
        if nums[right] != target {
            right--
        }
    }

    if len(nums) &gt; 0 &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target {
        return []int{left, right}
    }

    return []int{-1, -1}
}
</code></pre>]]></content></item><item><title>Leetcode 4</title><link>https://nathannaveen.dev/posts/leetcode-4/</link><pubDate>Mon, 01 Mar 2021 14:20:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-4/</guid><description>4. Median of Two Sorted Arrays
The idea of this solution is pretty simple, first append all the nums2 values to nums1. Then sort nums1. If there are a even number of values then the median is the middle two numbers added together and divided by 2. An example could be:
input: nums1 = [1,2], nums2 = [3,4] expected output: 2.5
When the two arrays are combined the new array would be [1, 2, 3, 4] and the two middle numbers are 2, and 3.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4. Median of Two Sorted Arrays</a></p>
<p>The idea of this solution is pretty simple, first append all the <code>nums2</code> values to <code>nums1</code>. Then sort <code>nums1</code>. If there are a even number of values then the median is the middle two numbers added together and divided by <code>2</code>. An example could be:</p>
<p><code>input: nums1 = [1,2], nums2 = [3,4]</code>
<code>expected output: 2.5</code></p>
<p>When the two arrays are combined the new array would be <code>[1, 2, 3, 4]</code> and the two middle numbers are <code>2</code>, and <code>3</code>. When <code>2</code> and <code>3</code> are added together we get <code>5</code>, and <code>5</code> divided by <code>2</code> is <code>2.5</code>.</p>
<p>If the number of values of <code>nums1</code> is odd, the median is the middle number.</p>
<pre><code>func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    nums1 = append(nums1, nums2...)
    sort.Ints(nums1)

    if len(nums1) % 2 == 0 {
        return float64(nums1[len(nums1) / 2 - 1] + nums1[len(nums1) / 2]) / 2
    } else {
        return float64(nums1[len(nums1)/2])
    }
}
</code></pre>]]></content></item><item><title>Leetcode 647</title><link>https://nathannaveen.dev/posts/leetcode-647/</link><pubDate>Mon, 01 Mar 2021 09:27:16 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-647/</guid><description>647. Palindromic Substrings
func countSubstrings(s string) int { res := 0 for i := 0; i &amp;lt; len(s); i++ { for j := 0; j &amp;lt;= len(s)-i; j++ { if s[j:j+i] != &amp;quot;&amp;quot; &amp;amp;&amp;amp; isPalindromic(s[j:j+i]) { res++ } } } if isPalindromic(s) { res++ } return res } func isPalindromic(s string) bool { left, right := 0, len(s)-1 for left &amp;lt;= right { if s[left] != s[right] { return false } left++ right-- } return true }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/palindromic-substrings/">647. Palindromic Substrings</a></p>
<pre><code>func countSubstrings(s string) int {
    res := 0
    for i := 0; i &lt; len(s); i++ {
        for j := 0; j &lt;= len(s)-i; j++ {
            if s[j:j+i] != &quot;&quot; &amp;&amp; isPalindromic(s[j:j+i]) {
                res++
            }
        }
    }
    if isPalindromic(s) {
        res++
    }
    return res
}

func isPalindromic(s string) bool {
    left, right := 0, len(s)-1

    for left &lt;= right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
</code></pre>]]></content></item><item><title>Leetcode 459</title><link>https://nathannaveen.dev/posts/leetcode-459/</link><pubDate>Sun, 28 Feb 2021 14:46:05 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-459/</guid><description>459. Repeated Substring Pattern
The idea of this solution is any substring that is repeated throughout the string s has to start at the 0&amp;lsquo;th index and end at another index, such as the 3&amp;lsquo;ed. This can be shown by using a image.
In both the examples the substrings that are repeated are green.
In the first example the substring abc starts at the 0&amp;lsquo;th index and ends at the 2&amp;rsquo;d index.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/repeated-substring-pattern/">459. Repeated Substring Pattern</a></p>
<p>The idea of this solution is any substring that is repeated throughout the string <code>s</code> has to start at the <code>0</code>&lsquo;th index and end at another index, such as the <code>3</code>&lsquo;ed. This can be shown by using a image.</p>
<p><img src="https://i.imgur.com/JB4X253.jpg" alt=""></p>
<blockquote>
<p>In both the examples the substrings that are repeated are green.</p>
<p>In the first example the substring <code>abc</code> starts at the <code>0</code>&lsquo;th index and ends at the <code>2</code>&rsquo;d index.</p>
<p>In the next example the substring is <code>Tacos</code> it starts at the <code>0</code>&lsquo;th index and ends at the <code>4</code>&lsquo;th index</p>
</blockquote>
<p>If you have noticed in both the examples the repeated substring has to start at the <code>0</code>&lsquo;th index and has to end at a following index.</p>
<p>The way my code checks whether it is a substring that repeats through out is it adds that substring to a empty string as many times as it fits in the string. Then it checks whether the new string is equal to <code>s</code>. If it is then <code>return true</code>. If it is never equal then <code>return false</code>.</p>
<pre><code>func repeatedSubstringPattern(s string) bool {
	for i := 0; i &lt; len(s); i++ {
		end := len(s)
		str := &quot;&quot;
		if i != 0 {
			end = len(s) / i
		}
		for j := 0; j &lt; end; j++ {
			str += s[0:i]
		}
		if str == s {
			return true
		}
	}
	return false
}
</code></pre>]]></content></item><item><title>Leetcode 5</title><link>https://nathannaveen.dev/posts/leetcode-5/</link><pubDate>Sun, 28 Feb 2021 11:41:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-5/</guid><description>5. Longest Palindromic Substring
In this solution we dont have to check whether the palindrome substring is greater than the max length substring because the length of the substring will always be greater than or equal to the length of the current max substring. This can be show in an image:
func longestPalindrome(s string) string { max := &amp;quot;&amp;quot; for i := 0; i &amp;lt; len(s); i++ { for j := 0; j &amp;lt;= len(s)-i; j++ { if isPalindromic(s[j : j + i]) { max = s[j : j + i] // getting the substring } } } if isPalindromic(s) { max = s } return max } func isPalindromic(s string) bool { left, right := 0, len(s) - 1 for left &amp;lt; right { if s[left] !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></p>
<p>In this solution we dont have to check whether the palindrome substring is greater than the max length substring because the length of the substring will always be greater than or equal to the length of the current max substring. This can be show in an image:</p>
<p><img src="https://i.imgur.com/k9YUTYG.jpg" alt=""></p>
<pre><code>func longestPalindrome(s string) string {
	max := &quot;&quot;
	for i := 0; i &lt; len(s); i++ {
		for j := 0; j &lt;= len(s)-i; j++ {
			if isPalindromic(s[j : j + i]) {
				max = s[j : j + i] // getting the substring
			}
		}
	}
	if isPalindromic(s) {
		max = s
	}
	return max
}

func isPalindromic(s string) bool {
	left, right := 0, len(s) - 1

	for left &lt; right {
		if s[left] != s[right] {
			return false
		}
		left++
		right--
	}
	return true
}
</code></pre>]]></content></item><item><title>Leetcode 1016</title><link>https://nathannaveen.dev/posts/leetcode-1016/</link><pubDate>Fri, 26 Feb 2021 13:58:32 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1016/</guid><description>1016. Binary String With Substrings Representing 1 To N
The idea of this solution is to loop through 1...N and then make the string by adding the bytes to a string called s. Then check if S contains the reversed string of the bytes. The string s is reversed by a helper function.
func queryString(S string, N int) bool { for i := 1; i &amp;lt;= N; i++ { s := &amp;quot;&amp;quot; n := i for n &amp;gt; 0 { if n &amp;amp; 1 == 1 { s += &amp;quot;1&amp;quot; } else { s += &amp;quot;0&amp;quot; } n &amp;gt;&amp;gt;= 1 } if !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/">1016. Binary String With Substrings Representing 1 To N</a></p>
<p>The idea of this solution is to loop through <code>1...N</code> and then make the string by adding the bytes to a string called <code>s</code>. Then check if <code>S</code> contains the reversed string of the bytes. The string <code>s</code> is reversed by a helper function.</p>
<pre><code>func queryString(S string, N int) bool {
    for i := 1; i &lt;= N; i++ {
        s := &quot;&quot;
        n := i

        for n &gt; 0 {
            if n &amp; 1 == 1 {
                s += &quot;1&quot;
            } else {
                s += &quot;0&quot;
            }
            n &gt;&gt;= 1
        }
        if !strings.Contains(S, reverse(s)) {
            return false
        }
    }
    return true
}

func reverse(s string) string {
    res := &quot;&quot;

    for _, i := range s {
        res = string(i) + res
    }
    return res
}
</code></pre><p>This solution is pretty much the same as the first solution but this solution doesn&rsquo;t use a outside function to reverse.</p>
<pre><code>func queryString(S string, N int) bool {
    for i := 1; i &lt;= N; i++ {
        s := &quot;&quot;
        n := i

        for n &gt; 0 {
            if n&amp;1 == 1 {
                s = &quot;1&quot; + s
            } else {
                s = &quot;0&quot; + s
            }
            n &gt;&gt;= 1
        }
        if !strings.Contains(S, s) {
            return false
        }
    }
    return true
}
</code></pre>]]></content></item><item><title>Leetcode 946</title><link>https://nathannaveen.dev/posts/leetcode-946/</link><pubDate>Fri, 26 Feb 2021 10:59:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-946/</guid><description>The idea of this solution is to append the pushed value to the stack. If peeked value is equal to the poped value then pop it off the stack, keep poping off the peeked value if it is equal to the poped value. This can be show in an image
func validateStackSequences(pushed []int, popped []int) bool { stack := []int{} popCounter := 0 for i := 0; i &amp;lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) !</description><content type="html"><![CDATA[<p>The idea of this solution is to append the pushed value to the stack. If peeked value is equal to the poped value then pop it off the stack, keep poping off the peeked value if it is equal to the poped value. This can be show in an image</p>
<p><img src="https://i.imgur.com/ovNR5Oy.jpg" alt=""></p>
<pre><code>func validateStackSequences(pushed []int, popped []int) bool {
    stack := []int{}
    popCounter := 0
    for i := 0; i &lt; len(pushed); i++ {
        stack = append(stack, pushed[i])
        for len(stack) != 0 &amp;&amp; popped[popCounter] == stack[len(stack)-1] {
            stack = stack[:len(stack)-1]
            popCounter++
            if popCounter == len(popped) {
                break
            }
        }
    }

    return len(stack) == 0
}
</code></pre>]]></content></item><item><title>Leetcode 448</title><link>https://nathannaveen.dev/posts/leetcode-448/</link><pubDate>Fri, 26 Feb 2021 10:28:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-448/</guid><description>448. Find All Numbers Disappeared in an Array
The idea of this solution is to add all the numbers to a map and then check whether the map doesn&amp;rsquo;t contain a number. If it doesn&amp;rsquo;t contain then add it to the array arr.
We return the array from the first position to the end because when we make the array it comes out with a 0 at the zeroth index. For example a input array could be [4,3,2,7,8,2,3,1].</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/">448. Find All Numbers Disappeared in an Array</a></p>
<p>The idea of this solution is to add all the numbers to a map and then check whether the map doesn&rsquo;t contain a number. If it doesn&rsquo;t contain then add it to the array <code>arr</code>.</p>
<p>We return the array from the first position to the end because when we make the array it comes out with a <code>0</code> at the zeroth index. For example a input array could be <code>[4,3,2,7,8,2,3,1]</code>. If we just returned <code>arr</code> then we would get <code>[0, 5, 6]</code> instead of <code>[5, 6]</code>. This can also be fixed by making <code>i</code> in the second loop start at <code>1</code> instead of <code>0</code>.</p>
<pre><code>func findDisappearedNumbers(nums []int) []int {

    m := make(map[int]int)
    arr := []int{}

    for _, i := range nums {
        m[i]++
    }

    for i := 0; i &lt;= len(nums); i++ {
        if _, ok := m[i]; !ok {
            arr = append(arr, i)
        }
    }
    return arr[1:]
}
</code></pre>]]></content></item><item><title>Leetcode 1704</title><link>https://nathannaveen.dev/posts/leetcode-1704/</link><pubDate>Thu, 25 Feb 2021 20:22:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1704/</guid><description>The idea of this solution is to first make the input string lowercase, and then add 1 to an integer array at the index of every letter, a = 0, b = 1, c = 2.... First we add to the array called first, then starting at a certain index start adding it to second.
After that, add the number of vowel that have occured. The code does this by doing</description><content type="html"><![CDATA[<p>The idea of this solution is to first make the input string lowercase, and then add <code>1</code> to an integer array at the index of every letter, <code>a = 0, b = 1, c = 2...</code>. First we add to the array called <code>first</code>, then starting at a certain index start adding it to <code>second</code>.</p>
<p>After that, add the number of vowel that have occured. The code does this by doing</p>
<pre><code>firstCounter += first[0] + first[4] + first[8] + first[14] + first[20]
secondCounter += second[0] + second[4] + second[8] + second[14] + second[20]
</code></pre><p>You might be wondering why the code is adding from <code>first</code> and <code>second</code> at the indices <code>0, 4, 8, 14, 20</code>. It is because the ascii values of <code>'a', 'e', 'i', 'o', 'u'</code> are <code>97, 101, 105, 111, 117</code>, and when they get the indices of <code>a = 0, b = 1, c = 2...</code> it is bascily subtracting <code>97</code> from each of them, so <code>97 - 97 = 0, 101 - 97 = 4, 105 - 97 = 8, 111 - 97 = 14, 117 - 97 = 20</code>.</p>
<p>All of this can be show with a example:</p>
<pre><code>input = &quot;TacosAreCool&quot;
output = true
</code></pre><p>First off we have to make the input lower case so it becomes <code>&quot;tacosarecool&quot;</code>.</p>
<p>Next we can add all the characters from to their appropriate arrays.</p>
<p><img src="https://i.imgur.com/kYBK5as.jpg" alt=""></p>
<p>You might be wondering why it says <code>tacosa</code> and <code>recool</code>. The front part of the word is <code>tacosa</code> and the back part is <code>recool</code> when the length of the string is divided by two, <code>len(tacosa) == 6</code> and <code>len(recool) == 6</code>. combine they make <code>tacosarecool</code>.</p>
<p>Then we need to add all the vowels together.</p>
<p><img src="https://i.imgur.com/DEf68sC.jpg" alt=""></p>
<p>The number of vowels for <code>tacosa</code> is <code>3</code> because there are two <code>a</code>&rsquo;s and one <code>o</code>. The number of vowels for <code>recool</code> is <code>3</code> as well, because there is one <code>e</code> and two <code>o</code>&rsquo;s.</p>
<p>Since both <code>tacosa</code> and <code>recool</code> both have the same amount of vowels we return <code>true</code>.</p>
<pre><code>func halvesAreAlike(s string) bool {
    first, second := make([]int, 26), make([]int, 26)
    firstCounter, secondCounter := 0, 0
    s = strings.ToLower(s)
    for i, i2 := range s {
        if i &lt; len(s)/2 {
            first[int(i2-'a')]++
        } else {
            second[int(i2-'a')]++
        }
    }

    firstCounter += first[0] + first[4] + first[8] + first[14] + first[20]
    secondCounter += second[0] + second[4] + second[8] + second[14] + second[20]

    return firstCounter == secondCounter
}
</code></pre>]]></content></item><item><title>Leetcode 1592</title><link>https://nathannaveen.dev/posts/leetcode-1592/</link><pubDate>Thu, 25 Feb 2021 15:48:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1592/</guid><description>1592. Rearrange Spaces Between Words
The idea of this solution is pretty simple, first split text by space. We have to split it manualy and not use a inbuild function because the text can contain multiple spaces inbetween words, and we have to count spaces. This can be show in an example:
input = &amp;quot; this is a sentence &amp;quot; inbuiltSplit = [&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;this&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;sentence&amp;quot;, &amp;quot;&amp;quot;] The Code:</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/rearrange-spaces-between-words/">1592. Rearrange Spaces Between Words</a></p>
<p>The idea of this solution is pretty simple, first split <code>text</code> by space. We have to split it manualy and not use a inbuild function because the text can contain multiple spaces inbetween words, and we have to count spaces. This can be show in an example:</p>
<pre><code>input = &quot;  this   is  a sentence &quot;

inbuiltSplit = [&quot;&quot;, &quot;&quot;, &quot;this&quot;, &quot;&quot;, &quot;&quot;, &quot;is&quot;, &quot;&quot;, &quot;a&quot;, &quot;sentence&quot;, &quot;&quot;]
</code></pre><p><strong>The Code:</strong></p>
<pre><code>func reorderSpaces(text string) string {
    spaceCounter := 0
    arr := []string{}
    str := &quot;&quot;
    res := &quot;&quot;
    for _, i := range text {
        if i == ' ' {
            if str != &quot;&quot; {
                arr = append(arr, str)
            }
            spaceCounter++
            str = &quot;&quot;
        } else {
            str += string(i)
        }
    }
    if str != &quot;&quot; {
        arr = append(arr, str)
    }
    space := &quot;&quot;

    if len(arr)-1 &gt; 0 {
        for i := 0; i &lt; spaceCounter/(len(arr)-1); i++ {
            space += &quot; &quot;
        }
        for i := 0; i &lt; len(arr)-1; i++ {
            res += arr[i] + space
        }
        res += arr[len(arr)-1]
        for i := 0; i &lt; spaceCounter%(len(arr)-1); i++ {
            res += &quot; &quot;
        }
    } else {
        for i := 0; i &lt; spaceCounter; i++ {
            space += &quot; &quot;
        }
        res = strings.Trim(text, space) + space
    }
    return res
}
</code></pre>]]></content></item><item><title>Leetcode 501</title><link>https://nathannaveen.dev/posts/leetcode-501/</link><pubDate>Thu, 25 Feb 2021 15:48:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-501/</guid><description>501. Find Mode in Binary Search Tree
The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.
func findMode(root *TreeNode) []int { max := 0 m := make(map[int]int) res := []int{} stack := []*TreeNode{} stack = append(stack, root) for len(stack) != 0 { pop := stack[len(stack)-1] stack = stack[:len(stack)-1] if pop !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree">501. Find Mode in Binary Search Tree</a></p>
<p>The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.</p>
<pre><code>func findMode(root *TreeNode) []int {
    max := 0
    m := make(map[int]int)
    res := []int{}
    stack := []*TreeNode{}
    stack = append(stack, root)

    for len(stack) != 0 {
        pop := stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        if pop != nil {
            m[pop.Val]++
            stack = append(stack, pop.Left, pop.Right)
        }
    }

    for i, i2 := range m {
        if i2 &gt; max {
            res = []int{i}
            max = i2
        } else if i2 == max {
            res = append(res, i)
        }
    }
    return res
}
</code></pre>]]></content></item><item><title>Leetcode 1768</title><link>https://nathannaveen.dev/posts/leetcode-1768/</link><pubDate>Thu, 25 Feb 2021 15:48:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1768/</guid><description>1768. Merge Strings Alternately
The idea of this solution is pretty simple. First loop through the word with the greater length. Then check whether the length of the word is greater than the current characters index, if so then add the character to the result.
func mergeAlternately(word1 string, word2 string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; int(math.Max(float64(len(word1)), float64(len(word2)))); i++ { if i &amp;lt; len(word1) { res += string(word1[i]) } if i &amp;lt; len(word2) { res += string(word2[i]) } } return res }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-strings-alternately/">1768. Merge Strings Alternately</a></p>
<p>The idea of this solution is pretty simple. First loop through the word with the greater length. Then check whether the length of the word is greater than the current characters index, if so then add the character to the result.</p>
<pre><code>func mergeAlternately(word1 string, word2 string) string {
    res := &quot;&quot;

    for i := 0; i &lt; int(math.Max(float64(len(word1)), float64(len(word2)))); i++ {
        if i &lt; len(word1) {
            res += string(word1[i])
        }
        if i &lt; len(word2) {
            res += string(word2[i])
        }
    }

    return res
}
</code></pre>]]></content></item><item><title>Leetcode 1296</title><link>https://nathannaveen.dev/posts/leetcode-1296/</link><pubDate>Thu, 25 Feb 2021 15:47:35 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1296/</guid><description>Divide array in sets of k consecutive numbers
The idea of this solution is to loop over the nums array until all the values are -1. The reason they all will become negative one is, whenever a item is used the value will become -1 so the code knows to not use that number again.
If you didn&amp;rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures: By the way sorry if my handwriting is messy</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/">Divide array in sets of k consecutive numbers</a></p>
<p>The idea of this solution is to loop over the <code>nums</code> array until all the values are <code>-1</code>. The reason they all will become negative one is, whenever a item is used the value will become <code>-1</code> so the code knows to not use that number again.</p>
<p><strong>If you didn&rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures:</strong>
<em>By the way sorry if my handwriting is messy</em></p>
<pre><code>input = [1, 2, 4, 3, 4, 5, 6, 3], k = 4
expected output = true
</code></pre><p>This is for getting the first consecutive sequence:
<img src="https://assets.leetcode.com/users/images/cfc0f0b7-8ffc-4ab0-8b83-143691f75526_1614179878.874795.png" alt="image"></p>
<p>And the second consecutive sequence:
<img src="https://assets.leetcode.com/users/images/eb4d3251-f7a8-4fe4-a3d2-ee89a0cc4e42_1614180843.1899865.png" alt="image"></p>
<p>Since we found two consecutive sequences we can return <code>true</code>.</p>
<hr>
<pre><code>func isPossibleDivide(nums []int, k int) bool {
	if len(nums)%k != 0 {
		return false
	}
	sort.Ints(nums)
	onlyNegetiveOnes := false

	for !onlyNegetiveOnes {
		onlyNegetiveOnes = true
		n := -1
		counter := 0
		for i := 0; i &lt; len(nums); i++ {
			if nums[i] != -1 {
				onlyNegetiveOnes = false
				if (n == -1) || (counter != k &amp;&amp; nums[i] == n+1) {
					n = nums[i]
					nums[i] = -1
					counter++
				} else if counter == k {
					break
				}
			}
		}
		if counter != k &amp;&amp; counter != 0 {
			return false
		}
	}
	return true
}
</code></pre>]]></content></item><item><title>Leetcode 1566</title><link>https://nathannaveen.dev/posts/leetcode-1566/</link><pubDate>Thu, 25 Feb 2021 15:46:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1566/</guid><description>1566. Detect Pattern of Length M Repeated K or More Times The idea of this can be show by this image
func containsPattern(arr []int, m int, k int) bool { counter := 0 for i := 0; i &amp;lt; len(arr) - m; i++ { if arr[i] != arr[i+m] { counter = 0 } else { counter++ } if counter == (k-1)*m { return true } } return false }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/">1566. Detect Pattern of Length M Repeated K or More Times</a>
The idea of this can be show by this image</p>
<p><img src="https://i.imgur.com/XEPQ2YV.jpg" alt=""></p>
<pre><code>func containsPattern(arr []int, m int, k int) bool {
    counter := 0

    for i := 0; i &lt; len(arr) - m; i++ {
        if arr[i] != arr[i+m] {
            counter = 0
        } else {
            counter++
        }

        if counter == (k-1)*m {
            return true
        }
    }

    return false
}
</code></pre>]]></content></item><item><title>Leetcode 976</title><link>https://nathannaveen.dev/posts/leetcode-976/</link><pubDate>Thu, 25 Feb 2021 13:50:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-976/</guid><description>976. Largest Perimeter Triangle
The idea of this solution is to sort the array and then keep on checking the largest three side lengths.
In the problem it asks us to &amp;ldquo;return the largest perimeter of a triangle with non-zero area.&amp;rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/largest-perimeter-triangle">976. Largest Perimeter Triangle</a></p>
<p>The idea of this solution is to sort the array and then keep on checking the largest three side lengths.</p>
<p>In the problem it asks us to &ldquo;return the largest perimeter of a triangle with non-zero area.&rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</p>
<p><img src="https://i.imgur.com/YOk3LWq.jpg" alt="">
<em>The triangle above is a proper triangle with an area greater than zero and we know that because the two smaller lengths, <code>5</code> and <code>5</code> added together is <code>10 &gt; 7</code>.</em>
<img src="https://i.imgur.com/HlspeLO.jpg" alt="">
<em>In the image above we can see that this is not a proper triangle because the area is zero. We know that this is not a proper triangle because the two smaller sides lengths are <code>4</code> and <code>3</code>. Four plus three is <code>7</code> and <code>7</code> is the length of the greatest triangle. So we don&rsquo;t have a triangle.</em></p>
<p><img src="https://i.imgur.com/LRxVW4L.jpg" alt="">
<img src="https://i.imgur.com/H1ySPp7.jpg" alt=""></p>
<p><em>The two images above are not proper triangles because the length of the two smaller sides are smaller than <code>7</code> and won&rsquo;t be able to form a triangle.</em></p>
<pre><code>func largestPerimeter(A []int) int {
    sort.Ints(A)
    for i := len(A) - 1; i &gt;= 2; i-- {
        if A[i] &lt; A[i - 1] + A[i - 2] {
            return A[i] + A[i - 1] + A[i - 2]
        }
    }
    return 0
}
</code></pre>]]></content></item><item><title>Leetcode 1523</title><link>https://nathannaveen.dev/posts/leetcode-1523/</link><pubDate>Wed, 24 Feb 2021 17:03:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1523/</guid><description>1523. Count Odd Numbers in an Interval Range
The idea of this solution is to get the number odd numbers from 0 to high, and then subtract the number of odd numbers from 0 to low - 1. The idea can be shown by an example:
high: 7 low : 3 The odd numbers from 0 to high (7). There are 4 odd numbers from 0 to 7. The odd numbers from 0 to low - 1 (2).</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/">1523. Count Odd Numbers in an Interval Range</a></p>
<p>The idea of this solution is to get the number odd numbers from <code>0</code> to <code>high</code>, and then subtract the number of odd numbers from <code>0</code> to <code>low - 1</code>. The idea can be shown by an example:</p>
<hr>
<pre><code>high: 7
low : 3
</code></pre><p><img src="https://assets.leetcode.com/users/images/2ca6929e-c01e-491f-9505-85dc303d779a_1614122599.638341.png" alt="image"></p>
<ul>
<li><em>The odd numbers from <code>0</code> to <code>high</code> (<code>7</code>).</em> There are <code>4</code> odd numbers from <code>0</code> to <code>7</code>.</li>
</ul>
<p><img src="https://assets.leetcode.com/users/images/0b5c316a-d1ed-426a-889f-2741c8b861f4_1614122953.1401534.png" alt="image"></p>
<ul>
<li><em>The odd numbers from <code>0</code> to <code>low - 1</code> (<code>2</code>).</em> There is <code>1</code> odd numbers from <code>0</code> to <code>2</code>.</li>
</ul>
<p>The number of odd numbers would be <code>4 - 1 = 3</code>. Three odd numbers.</p>
<hr>
<pre><code>func countOdds(low int, high int) int {
	return (high + 1)/2 - low / 2
}
</code></pre>]]></content></item><item><title>Leetcode 1637</title><link>https://nathannaveen.dev/posts/leetcode-1637/</link><pubDate>Wed, 24 Feb 2021 16:52:08 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1637/</guid><description>1637. Widest Vertical Area Between Two Points Containing No Points
points = {x, y} The idea of this solution is to ignore the y part of points because the vertical area is the made of vertical lines. Vertical lines are made up off one x value for every y value. An example could be the line x = 3, this is a vertical line at the x value 3.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/">1637. Widest Vertical Area Between Two Points Containing No Points</a></p>
<pre><code>points = {x, y}
</code></pre>
<p>The idea of this solution is to ignore the <code>y</code> part of <code>points</code> because the vertical area is the made of vertical lines. Vertical lines are made up off one <code>x</code> value for every <code>y</code> value. An example could be the line <code>x = 3</code>, this is a vertical line at the x value <code>3</code>.</p>
<p>The code first puts all the <code>x</code> points in the array <code>xPoints</code>. Then it sorts <code>xPoints</code> so all the <code>x</code>&rsquo;s are ready to use a sliding window approche of size two to find the greatest distance between all the two points. This can be show with this picture:</p>
<pre><code>input: [[8, 7], [9, 9], [7, 4], [9, 7]]
output: 1
</code></pre><p><img src="https://assets.leetcode.com/users/images/84ee2492-0703-4617-a38e-6691b4bcc3ea_1614125888.3422618.png" alt="image"></p>
<ul>
<li>Find all the <code>x</code>&rsquo;s and add them to a array</li>
<li>Sort the <code>x</code>&rsquo;s</li>
<li>Use a sliding window to find the max difference each <code>x</code> value.</li>
</ul>
<hr>
<pre><code>func maxWidthOfVerticalArea(points [][]int) int {
	xPoints := []int{}
	for _, point := range points {
		xPoints = append(xPoints, point[0])
	}
	sort.Ints(xPoints)
	max := 0

	for i := 0; i &lt; len(xPoints)-1; i++ {
		if xPoints[i+1]-xPoints[i] &gt; max {
			max = xPoints[i+1] - xPoints[i]
		}
	}

	return max
}
</code></pre>]]></content></item></channel></rss>